<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>redutan</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/" />
    <link rel="self" type="application/atom+xml" href="http://weblog.youre.space/redutan/atom.xml" />
    <id>tag:weblog.youre.space,2018-02-26:/redutan/17</id>
    <updated>2018-04-22T15:51:18Z</updated>
    
    <generator uri="http://www.sixapart.com/movabletype/">Movable Type 6.3.6</generator>

<entry>
    <title>상속의 위험성</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/04/000765.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.765</id>

    <published>2018-04-22T15:51:18Z</published>
    <updated>2018-04-22T15:51:18Z</updated>

    <summary>ToC 동기 사전지식 LSP Practice Summary 동기 어느 날이었습니다. 팀 내에서 상속에 대한 이야기를 하다가 주니어가 그럼 상속은 어떻게 써야하는지 궁금해 했습니다. 그런데 이 상속의 위험성을 설명하려고 하니, 말로만 하기에는 부족한 것 같고, 그렇다면 worst-case 코드를 보여줘야 하는데 시간이 없었습니다....</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>ToC</p>

<p>동기</p>

<p>사전지식</p>

<p>LSP</p>

<p>Practice</p>

<p>Summary</p>

<p>동기</p>

<p>어느 날이었습니다. 팀 내에서 상속에 대한 이야기를 하다가 주니어가 그럼 상속은 어떻게 써야하는지 궁금해 했습니다.</p>

<p>그런데 이 상속의 위험성을 설명하려고 하니, 말로만 하기에는 부족한 것 같고, 그렇다면 worst-case 코드를 보여줘야 하는데 시간이 없었습니다.</p>

<p>그래서 상속의 위험성에 대한 소스코드와 그것을 설명하는 블로그 아티클을 작성해야겠다는 생각이 들었습니다.</p>

<p>사전지식</p>

<p>Java 언어를 기본으로 설명합니다.</p>

<p>가변과 불변</p>

<p>객체지향은 가변(mutable)을 캡슐화(또는 관리)해서 복잡성을 제어합니다.</p>

<p>하지만 근본적으로 가변은 부수효과(side-effect)를 동반합니다.</p>

<p>그래서 가능하면 가변을 최소화 하는 것이 유리합니다.</p>

<p>이를 해결하기 위해서 불변(immutable)을 이용하는 것도 좋은 방법입니다.</p>

<p>접근제어자</p>

<p>public : 모두 접근 가능</p>

<p>protected : 자식 클래스와 같은 패키지 상에서 접근 가능</p>

<p>default(package) : 같은 패키지 상에서 접근 가능</p>

<p>private : 클래스 내에서만 접근 가능</p>

<p>public , protected 는 열려 있으며, default , private 는 닫혀 있다. - Joshua bloch</p>

<p>접근제어는 가능한 닫혀 있는 것이 좋습니다.</p>

<p>public field는 캡슐화되지 않으므로 Evil 으로 규정합니다.</p>

<p>불변식(불변조건)</p>

<p>클래스 불변식(Class Invariant)은 해당 클래스의 오브젝트가 가지는 제약사항을 말합니다.</p>

<p>즉 불변식이 깨지면 해당 객체는 유효하지 않다고 봐야하며 , 애플리케이션 내 클래스의 계약을 위배했으므로, 문제를 발생시킵니다.</p>

<p>예를 들어서 분수를 나타내는 클래스가 있다고 가정해 보겠습니다.</p>

<p>class 분수 {</p>

<p>public int 분자 ;</p>

<p>public int 분모 ;</p>

<p>@Override</p>

<p>public String toString () {</p>

<p>return 분자 + "/" + 분모 ;</p>

<p>}</p>

<p>}</p>

<p>class 분수 Test {</p>

<p>@Test</p>

<p>public void test 분수 _invalid () {</p>

<p>분수 분수객체 = new 분수 ();</p>

<p>분수객체 . 분자 = 1 ;</p>

<p>분수객체 . 분모 = 0 ; // !!! 분모는 0이 아니여야함 (불변식이 깨짐)</p>

<p>}</p>

<p>}</p>

<p>내부 필드가 public이기 때문에 캡슐화를 통해서 불변식을 강제할 수가 없습니다.</p>

<p>불변식 제약사항을 강제하는 메소드를 재정의함으로써도 깨질 수도 있습니다.</p>

<p>LSP</p>

<p>서브타입(sub-type)은 그것의 기반 타입(base-type)으로 치환 가능해야 한다.</p>

<p>그냥 단순하게 기반 타입으로 치환만 된다는 것을 의미하지는 않습니다. 기반 타입의 행위들을 서브 타입의 행위들로 대치해도 문제가 없고, 불변식도 깨지지 않아야 함을 의미합니다.</p>

<p>LSP를 자체를 설명하기 보다는 LSP가 위배되는 상황을 통해서 역으로 LSP를 알아보겠습니다.</p>

<p>유명한 Rectangle(직사각형) - Square(정사각형) 예제를 통해서 이를 확인해 보겠습니다.</p>

<p>class Rectangle {</p>

<p>private int width ;</p>

<p>private int height ;</p>

<p>public void setWidth ( int width ) {</p>

<p>this . width = width ;</p>

<p>}</p>

<p>public void setHeight ( int height ) {</p>

<p>this . height = height ;</p>

<p>}</p>

<p>public final int getArea () {</p>

<p>return width * height ;</p>

<p>}</p>

<p>}</p>

<p>class Square extends Rectangle {</p>

<p>@Override</p>

<p>public void setWidth ( int width ) {</p>

<p>super . setWidth ( width );</p>

<p>super . setHeight ( height );</p>

<p>}</p>

<p>@Override</p>

<p>public void setHeight ( int height ) {</p>

<p>this . setWidth ( height );</p>

<p>}</p>

<p>}</p>

<p>위 정도면 충분히 LSP 를 만족한다고 보입니다. 과연 그럴까요?</p>

<p>먼저 Square 클래스의 불변식을 알아봅시다. 정사각형이기 때문에 길이와 높이가 같은 것이 불변식입니다.</p>

<p>Rectangle 는 어떤 불변식을 가질까요? 길이와 높이가 무조건 같이 변경되면 직사각형의 불변식이 위배됩니다. - 두 타입 간 충돌이 발생하는 느낌도 있습니다.</p>

<p>즉, Square 는 길이와 높이를 무조건 같이 변경하게 되지만, Rectangle 는 길이와 높이가 같이 변경되면 예상치 못한 부수효과로 인해 불변식이 깨지게 됩니다.</p>

<p>Rectangle 의 불변식이 깨지게 됨은 상위 타입으로 치환이 불가능하다로 연결되므로 LSP도 위배하게 됩니다.</p>

<p>물론 불변식이 깨진다고 해서 무조건 LSP가 위배되는 것은 아닙니다.</p>

<p>Solution</p>

<p>먼저 상속을 유지한 상태에서 해결 방안을 알아보겠습니다.</p>

<p>class Retangle {</p>

<p>private final int width ;</p>

<p>private final int height ;</p>

<p>public Rectangle ( int width , int height ) {</p>

<p>this . width = width ;</p>

<p>this . height = height ;</p>

<p>}</p>

<p>public final int getArea () {</p>

<p>return width * height ;</p>

<p>}</p>

<p>}</p>

<p>class Square extends Rectangle {</p>

<p>public Square ( int length ) {</p>

<p>super ( length , length );</p>

<p>}</p>

<p>}</p>

<p>부수효과는 가변메서드(Setter)에서 발생합니다. 그럼 애초에 원인이 되는 가변을 모두 제거해서 위와 같이 불변(Immutable)을 통해서 문제를 해결 할 수 있습니다.</p>

<p>Another Solution</p>

<p>다른 방법을 알아볼까요?</p>

<p>애초에 이 애플리케이션 세계에서 사각형과 정사각형은 상속구조가 어울리지 않는 것 같습니다.</p>

<p>interface Shape {</p>

<p>int getArea ();</p>

<p>}</p>

<p>final class Rectangle implements Shape {</p>

<p>private final int width ;</p>

<p>private final int height ;</p>

<p>public Rectangle ( int width , int height ) {</p>

<p>this . width = width ;</p>

<p>this . height = height ;</p>

<p>}</p>

<p>@Override</p>

<p>public int getArea () {</p>

<p>return width * height ;</p>

<p>}</p>

<p>}</p>

<p>final class Square implements Shape {</p>

<p>private Rectangle target ;</p>

<p>public Square ( int length ) {</p>

<p>setLength ();</p>

<p>}</p>

<p>public void setLength ( int length ) {</p>

<p>this . target = new Rectangle ( length , length );</p>

<p>}</p>

<p>@Override</p>

<p>public int getArea () {</p>

<p>return target . getArea ();</p>

<p>}</p>

<p>}</p>

<p>상속 보다는 합성(Composition) 원칙에 입각해서 위와 같이 수정하는 것도 한 방법입니다.</p>

<p>실제로 중요한 것은 넓이를 구하는 행위이지 사각형이냐, 정사각형이냐는 그 다음 문제입니다.</p>

<p>또한 합성을 이용하면 Setter(‘setLength’)가 있더라도 불변식이 깨지는 부수효과가 발생하지 않습니다.</p>

<p>Practice</p>

<p>아래 다양한 예시를 통해서 더 안전한 상속을 구현하는 방법을 알아보겠습니다.</p>

<p>메서드 재정의</p>

<p>메서드가 재정의 불가능하게 final 로 닫는 것이 좋습니다.</p>

<p>Bad</p>

<p>base : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/override/BadSuperObject.java</p>

<p>Good</p>

<p>https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/override/GoodSuperObject.java</p>

<p>Support 타입</p>

<p>상속을 단순 코드 재사용으로 사용하는 경우(추상 메서드가 없는 경우)에는 합성(Composition)을 사용하는 것이 좋습니다.</p>

<p>Bad</p>

<p>base : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/support/ProcessSupport.java</p>

<p>sub : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/support/BadMainProcess.java</p>

<p>Good</p>

<p>helper : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/support/ProcessHelper.java</p>

<p>client : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/support/GoodMainProcess.java</p>

<p>Template</p>

<p>템플릿 메소드 패턴의 경우 아래와 같은 코드로 정형화 하는 것이 좋습니다. - 이것은 상속을 이용한 Good Practice 중 하나입니다.</p>

<p>템플릿 패턴은 변하는 부분과 변하지 않는 부분의 관심사 분리가 중요합니다.</p>

<p>변하는 부분은 다형성을 위해 열어두고 변하지 않는 부분은 불변 템플릿(final)으로 만듭니다.</p>

<p>Good Sample 중 일부 코드</p>

<p>public abstract class AbstractSafePrefixContentHolder implements ContentHolder {</p>

<p>// 가능한 필드는 닫고 불변화 시킨다. 접근이 필요할 때만 점진적으로 연다.</p>

<p>private final String content ;</p>

<p>public AbstractSafePrefixContentHolder ( String content ) {</p>

<p>this . content = Objects . requireNonNull ( content ); // 여기에서 제약조건을 추가할 수 있다. : 선행조건으로 불변식 강제</p>

<p>}</p>

<p>@Override // 템플릿 : 재정의 불가능하게 final</p>

<p>public final String getContent () {</p>

<p>return getPrefix () + content ;</p>

<p>}</p>

<p>// 다형성으로써 추상 메서드만 오픈시킨다.</p>

<p>abstract protected String getPrefix ();</p>

<p>}</p>

<p>Bad</p>

<p>base : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/template/AbstractPrefixContentHolder.java</p>

<p>sub : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/template/BadContentHolder.java</p>

<p>Good</p>

<p>base : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/template/AbstractSafePrefixContentHolder.java</p>

<p>sub : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/template/GoodContentHolder.java</p>

<p>Summary</p>

<p>불변식을 지킵니다.</p>

<p>접근제어는 가능한 닫습니다 : field는 private 로</p>

<p>가능한 변경을 최소화 합니다 : final</p>

<p>불변을 이용하거나, 인터페이스를 통한 합성으로 변경해 봅니다.</p>

<p>예외</p>

<p>하지만 모든 경우에서 위 원칙을 지키는 것은 힘들수도 있습니다.</p>

<p>상속의 위험성을 모두 파악한 상태에서 문서(javadoc)를 통해서 제약사항을 명시해서 언어로써 강제하는 것이 아니라 프로그래머가 스스로 제약사항을 지키게 하는 것도 한 방법입니다.</p>

<p>http://redutan.github.io/2016/02/26/effective-java2-chapter04#rule-17—계승을-위한-설계와-문서를-갖추거나-그럴-수-없다면-계승을-금지하라</p>

<p>그리고 특정 도메인(ex:환경설정)에서는 위 상속의 위험성을 무시할 수도 있습니다.</p>

<p>Reference</p>

<p>github : https://github.com/redutan/dangers-of-inheritance/</p>

<p>http://redutan.github.io/2016/02/26/effective-java2-chapter04</p>

<p>http://redutan.github.io/2017/06/10/clean-software-part02-2</p>

<p>https://en.wikipedia.org/wiki/Class_invariant</p>

<p>https://ko.wikipedia.org/wiki/리스코프_치환_원칙</p>

<p>상속의 위험성 was originally published by MJ at DevOOOOOOOOP on April 21, 2018.</p>

<p>source : http://redutan.github.io/2018/04/21/dangers-of-inheritance</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>IntelliJ SonarLint Plugin</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/04/000743.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.743</id>

    <published>2018-04-11T07:10:29Z</published>
    <updated>2018-04-11T07:10:29Z</updated>

    <summary>동기 시작은 popit 아티클 어느날 popit에 sonarqube를 이용한 코드 자동리뷰 아티클이 올라왔습니다. http://www.popit.kr/내코드를-자동으로-리뷰해준다면-by-sonarqube/ 조직장(요다 )이 이것을 팀 내에 적용해보자고 해서 (이미 저희 팀은 sonarqube로 정적분석을 하고 있습니다.) 적용을 시작합니다. 생각보다 적용이 쉽지 않으며, 설정 포인트도 많습니다. 물론 한 번 힘들게...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[동기

시작은 popit 아티클

어느날 popit에 sonarqube를 이용한 코드 자동리뷰 아티클이 올라왔습니다.

http://www.popit.kr/내코드를-자동으로-리뷰해준다면-by-sonarqube/

조직장(요다 )이 이것을 팀 내에 적용해보자고 해서 (이미 저희 팀은 sonarqube로 정적분석을 하고 있습니다.) 적용을 시작합니다.

생각보다 적용이 쉽지 않으며, 설정 포인트도 많습니다. 물론 한 번 힘들게 설정하면 그 이후에는 자동화되기 때문에 tradeoff 할 만 하지요. 적용할 프로젝트 수 자체가 많으면 초기 설정이 조금 힘들 순 있습니다. - 하지만 단순 반복 작업이기 때문에 복사하기-붙여넣기 를 잘하면 되긴 합니다. -

하지만 코드를 작성하고, 커밋하고, 푸시하고, PullRequest를 올려야지 정적분석 피드백을 받을 수 있습니다. 즉, 코드 작성 시와 정적분석 피드백 시 사이의 시간 차가 너무 큽니다.

그래서 코드를 작성과 가능한 가까운 시간에 바로 피드백 을 받는 것이 더 좋지 않을까 하는 생각이 들었습니다.

대안 : SonarLint

그러던 중 팀원 콤틴 이 IDEA plugin인 SonarLint 를 사용하는 것을 추천하였습니다.

팀 내에서 IntelliJ IDEA를 사용하고 있었고, 확실히 합리적인 선택이 될 것 같았습니다.

SonarLint 적용

Install

preference > plugins

SonarLint 검색

결과창 내 Search in repositories 링크 선택 or 하딘 Browse repositories... 버튼 선택

Install and Restart IntelliJ IDEA

Staring과 다운로드 갯수가 많고, 최근 업데이트도 지속되고 있는 것 같아서 믿을만한 플러그인 같습니다

Install 확인

Configuration

기본적인 설정만으로도 충분히 사용할 수 있으며 sonarqube 서버가 없어도 사용에 문제가 없습니다.

SonarQube 서버 연동

서버 연동을 하게 되면 더 다양한 분석룰을 팀 내 전반적으로 일관성 있게 관리할 수 있습니다.

preference > Other Settings > SoanrLint General Settings

Automatically trigger analysis 체크하는 것을 추천

또는 해제하고 commit 시에만 분석하는것도 좋음

위 화면을 통해서 적절하게 설정하면 됨

SoanrLint Project Settings 를 통한 설정도 가능

Commit 시 분석 추가

커밋(Cmd + K ) 창에서

Perform SonarLint analysis 를 선택 (기본으로 체크되어 있음)

개인적으로 추천 commit 할 때마다 분석이 됨

Usage

현재 파일 분석

mac : Cmd + Opt + S

or

그 외 가능한 사용법

전체 파일 분석 : Analyze All Files with SonarLint

VCS(ex: git)상 변경된 분석 검사 : Analyze VCS Changed Files with SonarLint

*Cmd + Opt + A , SonarLint 로 검색한 액션들

Analyze Example

public class AccountRestController {

...

@PostMapping

public ResponseEntity 

IntelliJ SonarLint Plugin was originally published by MJ at DevOOOOOOOOP on April 11, 2018.

source : http://redutan.github.io/2018/04/11/intellij-sonarlint-plugin<br />---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW
]]>
        
    </content>
</entry>

<entry>
    <title>클린소프트웨어 Part 6. ETS 사례 연구</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/02/000544.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.544</id>

    <published>2018-02-26T05:53:27Z</published>
    <updated>2018-02-26T05:53:27Z</updated>

    <summary>비지터 패턴 클래스 계층 구조에 새로운 메소드를 추가할 필요가 있지만, 그렇게 하는 작업은 고통스럽거나 설계를 해치게 된다. 디자인 패턴의 비지터 집합 타입 계층 구조를 변경하지 않고도 새로운 메소드를 계층 구조에 추가할 수 있음 비지터(Visitor) 비순환 비지터(Acyclic Visitor) 데코레이터(Decorator) 비지터 패턴...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>비지터 패턴</p>

<p>클래스 계층 구조에 새로운 메소드를 추가할 필요가 있지만, 그렇게 하는 작업은 고통스럽거나 설계를 해치게 된다.</p>

<p>디자인 패턴의 비지터 집합</p>

<p>타입 계층 구조를 변경하지 않고도 새로운 메소드를 계층 구조에 추가할 수 있음</p>

<p>비지터(Visitor)</p>

<p>비순환 비지터(Acyclic Visitor)</p>

<p>데코레이터(Decorator)</p>

<p>비지터 패턴 상세</p>

<p>이중 디스패치(dual dispatch) : 실행되는 연산이 요청의 종류와 두 수신자의 타입에 따라 달라진다는 뜻</p>

<p>비지터 패턴 클래스 다이어그램</p>

<p>비지터 패턴 시퀀스 다이어그램</p>

<p>연산의 변화 vs 구조의 변화</p>

<p>새로운 구상체가 계속 추가된다면 Visitor은 독이 된다.</p>

<p>새로운 연산이 계속 추가된다면 Vistor은 좋은 선택이다.</p>

<p>비순환 비지터 패턴</p>

<p>down-casting가 있어서 쓰기가 꺼려진다.</p>

<p>타입안정성이 약해짐</p>

<p>만약 generic 을 이용할 수 있다면 더 낫지 않을까?</p>

<p>public void accept ( ModemVisitor v ) {</p>

<p>try {</p>

<p>ErniedModemVisitor ev = ( ErnieModemVisitor ) v ; // !!!</p>

<p>ev . visit ( this );</p>

<p>} catch ( ClassCastException e ) {</p>

<p>}</p>

<p>}</p>

<p>p.505 ErnieModem.java 일부</p>

<p>데코레이터 패턴</p>

<p>소리나는 다이얼 모뎀을 만들고 싶다</p>

<p>OCP, SRP 원칙을 지킬려면 어떻게 해야할까?</p>

<p>데코레이터 !!!</p>

<p>public class LoudDialModem implements Modem {</p>

<p>private Model modem ;</p>

<p>public LoudDialModem ( Modem m ) {</p>

<p>this . modem = m</p>

<p>}</p>

<p>public void dial ( String pno ) {</p>

<p>modem . setSpeakerVolume ( 10 ); // 데코레이팅!!!</p>

<p>modem . dial ( pno )</p>

<p>}</p>

<p>...</p>

<p>}</p>

<p>확장 객체 패턴</p>

<p>아답터 패턴과 유사하다.</p>

<p>단점은 역시나 많은 subclass를 동반하는 것이다.</p>

<p>장점은 OCP와 SRP를 지킬 수 있다</p>

<p>확장 객체 패턴 클래스 다이어그램</p>

<p>참고 : The Extension Objects Pattern.pdf</p>

<p>스테이트 패턴</p>

<p>유한 상태 오토마타의 개괄</p>

<p>유한 상태 기계 : Finite State Machine</p>

<p>ex) 개찰구</p>

<p>개찰구 상태 다이어그램</p>

<p>구현기법 : 중첩된 switch/case</p>

<p>switch ( state ) {</p>

<p>case LOCKED :</p>

<p>switch ( event ) {</p>

<p>case COIN :</p>

<p>state = UNLOCKED ;</p>

<p>turnstileController . unlock ();</p>

<p>break ;</p>

<p>case PASS :</p>

<p>turnstileController . alarm ();</p>

<p>break ;</p>

<p>}</p>

<p>break ;</p>

<p>case UNLOCKED :</p>

<p>switch ( event ) {</p>

<p>case COIN :</p>

<p>turnstileController . thankyou ();</p>

<p>break ;</p>

<p>case PASS :</p>

<p>state = LOCKED ;</p>

<p>turnstileController . lock ();</p>

<p>break ;</p>

<p>}</p>

<p>break ;</p>

<p>}</p>

<p>turnstile : 개찰구</p>

<p>접근제어가 패키지인 상태변수</p>

<p>ISSUE 테스트를 진행할려면 테스트에서 상태를 변경할 수 있어야 한다.</p>

<p>이를 위해서 같은 패키지에서 만들어지는 테스트를 위해서 상태 변수를 패키지 접근제어로 변경하였다.</p>

<p>effective-java에 의하면 패키지 접근제어도 캡슐화가 깨지지 않는 것으로 보이므로 큰 문제가 없다고 판단되며, 본인도 종종 이것을 애용하는 편이다.</p>

<p>하지만 가능했다면, 패키지 생성자나 패키지 setter 메소드로 조금 더 제한하면 좋을 것 같다.</p>

<p>만약 C++이었다면 friend로 해결가능했을 것이다.</p>

<p>중첩된 switch/case의 장단점</p>

<p>간단한 상황에서는 가독성이 높고 효율적</p>

<p>복잡한 상황에서는 가독성이 떨어지고 유지보수도 어려워지며, 실수에 취약하다.</p>

<p>중복코드도 많이 생긴다.</p>

<p>구현기법 : 전이 테이블 해석</p>

<p>// 테이블 구축</p>

<p>public Trunstile ( TurnstileController action ) {</p>

<p>turnstileController = action ;</p>

<p>addTransition ( LOCKED , COIN , UNLOCKED , unlock ()); // 마지막 메서드는 람다식으로 하면 더 나을 것 같다.</p>

<p>addTransition ( LOCKED , PASS , LOCKED , alarm ());</p>

<p>addTransition ( UNLOCKED , COIN , UNLOCKED , thankyou ());</p>

<p>addTransition ( UNLOCKED , PASS , LoCKED , lock ());</p>

<p>}</p>

<p>...</p>

<p>// 전이 엔진</p>

<p>public void event ( int event ) {</p>

<p>for ( Transition transition : transitions ) {</p>

<p>// 아래 분기문은 transition의 메서드로 분기하면 좋을 것 같다. : transition.isTransferable(state, event)</p>

<p>if ( state == transition . currentState && event == transition . event ) {</p>

<p>state = transition . newState ;</p>

<p>transition . action . execute ();</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>전이 테이블 해석의 장단점</p>

<p>정규적이며, 가독성이 좋다.</p>

<p>runtime 시 테이블 교체 가능(동적 제어)</p>

<p>ISSUE 테이블의 양이 커지면 검색 시간이 오래 걸린다??</p>

<p>ISSUE 테이블을 지원하기 위한 코드의 양도 많아 진다??</p>

<p>구현기법 : 스테이트 패턴</p>

<p>ISSUE 하지만 예제에서는 Turnstile가 구상상태(TunstileLockedState 등)에 의존하고 있어서 DIP 원칙이 깨지고 있다. - p.544</p>

<p>Gof : 스테이트 패턴</p>

<p>Tcp를 예제로 한 스테이트 패턴 클래스 다이어그램</p>

<p>TCP Established : 연결상태</p>

<p>TCP Listen : 연결대기</p>

<p>TCP Closed : 종료</p>

<p>참고 : TCP 연결 상태 의미</p>

<p>스테이트와 스트래터지</p>

<p>스테이트 : 상태의 다형성 확보</p>

<p>스트래터지 : 알고리즘(행위)의 다형성 확보</p>

<p>context의 상태 변경이 일어나는가?</p>

<p>스테이트 패턴의 장단점</p>

<p>OCP, SRP를 만족할 수 있다.</p>

<p>상태 마다 각각 subclass가 필요해서 비용이 많이 든다.</p>

<p>상태 기계의 모든 논리를 한 번에 파악할 수 없다 (vs 전이 테이블)</p>

<p>상태 기계 컴파일러(SMC)</p>

<p>전이 테이블 + 스테이트 패턴 = 3차원 유한 상태 기계(THREE-LEVEL FINITE STATE MACHINE)</p>

<p>상태 기계 컴파일러 장단점</p>

<p>그냥 좋다. = Best practice</p>

<p>클린소프트웨어 Part 6. ETS 사례 연구 was originally published by MJ at DevOOOOOOOOP on October 08, 2017.</p>

<p>source : http://redutan.github.io/2017/10/08/clean-software-part06</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

</feed>
