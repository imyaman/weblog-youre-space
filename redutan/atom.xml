<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>redutan</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/" />
    <link rel="self" type="application/atom+xml" href="http://weblog.youre.space/redutan/atom.xml" />
    <id>tag:weblog.youre.space,2018-02-26:/redutan/17</id>
    <updated>2018-06-07T03:16:00Z</updated>
    
    <generator uri="http://www.sixapart.com/movabletype/">Movable Type 6.3.6</generator>

<entry>
    <title>IDDD 111장. 팩토리</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/06/000947.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.947</id>

    <published>2018-06-07T03:16:00Z</published>
    <updated>2018-06-07T03:16:00Z</updated>

    <summary>애그리게잇을 생성하는 책임을 가지는 메소드나 객체를 말한다. 애그리게잇 생성을 캡슐화 도메인 모댈 내의 팩토리 복잡한 객체와 애그리게잇 인스턴스를 생성하는 책임을 별도의 객체로 이동시키자. 여기서의 책임은 도메인 모델과 관련이 있지 않지만, 여전히 도메인 설계를 구성하는 한 요소 다. 모든 복잡한 조립...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>애그리게잇을 생성하는 책임을 가지는 메소드나 객체를 말한다.</p>

<p>애그리게잇 생성을 캡슐화</p>

<p>도메인 모댈 내의 팩토리</p>

<p>복잡한 객체와 애그리게잇 인스턴스를 생성하는 책임을 별도의 객체로 이동시키자. 여기서의 책임은 도메인 모델과 관련이 있지 않지만, 여전히 도메인 설계를 구성하는 한 요소 다. 모든 복잡한 조립 과정을 캡슐화하고, 클라이언트가 인스턴스화된 객체의 구체적 클래스를 참조할 필요가 없도록 인터페이스를 제공하자. 전체 애그리게잇을 하나의 조각(원자성)으로 생성하고 고정자(Invariant)를 지정하자 [Evans]</p>

<p>팩토리 메소드 : 이 책은 주로 여기만 나옴</p>

<p>팩토리 객체(클래스)</p>

<p>애그리게잇 생성이 매우 복잡하고 다른 객체의 도움이 필요하면 클래스 분리를 하는 것이 좋은 것 같다.</p>

<p>가능한 팩토리 위치</p>

<p>애그리게잇 루트</p>

<p>정정 생성자를 통해서 도메인 의도가 나오면 더 좋다. static Task#forDraft()</p>

<p>아니면 상위 루트에서 하위 엔터리 생성도 가능 Project#createTask()</p>

<p>도메인 서비스 : 서비스 기반 팩토리</p>

<p>ProjectService#createProject()</p>

<p>팩토리 : 이 책은 다루지 않음</p>

<p>ProjectFactory#create()</p>

<p>애그리게잇 루트상의 팩토리 메소드</p>

<p>바운디드 컨텍스트</p>

<p>애그리게잇</p>

<p>팩토리 메소드</p>

<p>식별자와 액세스 컨텍스트</p>

<p>Tenant</p>

<p>offerRegisterationInvitation()</p>

<p>provisionGroup()</p>

<p>provisionRole()</p>

<p>registerUser()</p>

<p>협업 컨텍스트</p>

<p>Calendar</p>

<p>scheduleCalendarEntry()</p>

<p>Forun</p>

<p>startDiscussion()</p>

<p>Discussion</p>

<p>post()</p>

<p>애자일 PM 컨텍스트</p>

<p>Product</p>

<p>planBacklogItem()</p>

<p>scheduleRelease()</p>

<p>scheduleSprint()</p>

<p>CalendarEntry 인스턴스 생성하기</p>

<p>@Entity</p>

<p>class Calendar extends AbstractAggregateRoot {</p>

<p>CalendarEntry scheduleCalendarEntry (...) {</p>

<p>CalendarEntry calendarEntry = new CalendarEntry (...);</p>

<p>this . registerEvent ( new CalendarEntryScheduled (...));</p>

<p>return calendarEntry ;</p>

<p>}</p>

<p>}</p>

<p>유비쿼터스 언어에 부합되는 도메인이 표현됨 : scheduleCalendarEntry</p>

<p>보호절이 없다 : 어짜피 new CalendarEntry(...) 가 책임짐</p>

<p>Setter 를 사용하지 않는다. > 원자성 + 부수효과 줄어듬 + 불변식 강제 가 쉬움</p>

<p>이벤트 발행 : CalendarEntryScheduled</p>

<p>인자의 갯수가 줄어든다.</p>

<p>scheduleCalendarEntry(...) 에서는 11개가 요구되지만, new CalendarEntryScheduled(...) 에서는 9개로 줄어든다.</p>

<p>개인적으로는 이것도 인자를 캡슐화 시켜서 객체로 말아버리는 것이 좋은 것 같다. 9개의 인자라도 너무 많은 것 같음.</p>

<p>하지만</p>

<p>CalendarEntry 를 생성하기 위해서는 꼭 Calendar 인스턴스 가 요구됨</p>

<p>이는 DB 조회라는 부하가 추가됨</p>

<p>Discussion 인스턴스 생성하기</p>

<p>@Entity</p>

<p>class Forum extends AbstractAggregateRoot {</p>

<p>Discussion startDiscussion (</p>

<p>DiscussionId discussionId ,</p>

<p>Author author ,</p>

<p>String subject ) {</p>

<p>if ( this . isClosed ()) {</p>

<p>throw new IllegalStateException ( "Forum is closed" );</p>

<p>}</p>

<p>Discussion discussion = new Discussion (</p>

<p>this . tenant (),</p>

<p>this . forumId (),</p>

<p>discussionId ,</p>

<p>author ,</p>

<p>subject );</p>

<p>registerEvent ( new DiscussionStarted (...));</p>

<p>return discussion ;</p>

<p>}</p>

<p>}</p>

<p>포럼이 열린 경우에만 토론을 시작할 수 있다. : this.isClosed()</p>

<p>인자 5개 중 3개만 있으면 된다. : 나머지 2개는 포럼에서 제공</p>

<p>역시나 유비쿼터스 언어가 표현된다. : startDiscussion</p>

<p>서비스의 팩토리</p>

<p>package com . saasovation . collaboration . domain . model . collaborator ;</p>

<p>interface CollaboratorSerice {</p>

<p>Author authorFrom ( Tenant tenant , String identity );</p>

<p>Creator creatorFrom ( Tenant tenant , String identity );</p>

<p>Moderator moderatorFrom ( Tenant tenant , String identity );</p>

<p>Owner ownerFrom ( Tenant tenant , String identity );</p>

<p>Participant participantFrom ( Tenant tenant , String identity );</p>

<p>}</p>

<p>// infrastructure.services !!!</p>

<p>package com . saasovation . collaboration . infrastructure . services ;</p>

<p>class UserRoleToCollaborationService implements CollaboratorSerice {</p>

<p>@Override</p>

<p>public Author authorFrom ( Tenant tenant , String identity ) {</p>

<p>return ( Author ) userInRoleAdapter . toCollaborator (</p>

<p>tenant , identity , "Author" , Author . class );</p>

<p>)</p>

<p>}</p>

<p>}</p>

<p>package com . saasovation . collaboration . domain . model . collaborator ;</p>

<p>class Author extends Collaborator {</p>

<p>...</p>

<p>}</p>

<p>기술적 구현이므로 인프라 계층 의 모듈에 위치한다.</p>

<p>어댑터에 의존한다.</p>

<p>UserInRoleAdapter 는 외래 컨텍스트와 의사소통 책임만 갖는다.</p>

<p>CollaboratorTranslator 는 바운디드 컨텍스트 내 도메인 객체로 변환 책임만 갖는다.</p>

<p>협업에서는 identity 식별자와 액세스에서는 username</p>

<p>마무리</p>

<p>유비쿼터스 언어로 애그리게잇을 생성</p>

<p>애그리게잇의 팩토리 메서드 VS 서비스의 팩토리 메서드</p>

<p>IDDD 111장. 팩토리 was originally published by MJ at DevOOOOOOOOP on June 07, 2018.</p>

<p>source : http://redutan.github.io/2018/06/07/IDDD-chapter11</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>IDDD 10장. 애그리게잇</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/06/000940.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.940</id>

    <published>2018-06-04T16:36:12Z</published>
    <updated>2018-06-04T16:36:12Z</updated>

    <summary>일관성 경계 내에서 엔터티와 값 객체의 묶음 일관성 경계 의 기준은 같은 트랜잭션인가로 검증된다. 애그리게잇 내의 불변식(invariant)? 스크럼 핵심 도메인에서 애그리게잇 사용하기 기능 목록 제품은 백로그 아이템과 릴리스, 스프린트를 포함한다. 새로운 제품 백로그 아이템을 계획했다. 새로운 제품 릴리스를 계획했다. 새로운...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>일관성 경계 내에서 엔터티와 값 객체의 묶음</p>

<p>일관성 경계 의 기준은 같은 트랜잭션인가로 검증된다.</p>

<p>애그리게잇 내의 불변식(invariant)?</p>

<p>스크럼 핵심 도메인에서 애그리게잇 사용하기</p>

<p>기능 목록</p>

<p>제품은 백로그 아이템과 릴리스, 스프린트를 포함한다.</p>

<p>새로운 제품 백로그 아이템을 계획했다.</p>

<p>새로운 제품 릴리스를 계획했다.</p>

<p>새로운 제품 스프린트 일정을 수립했다.</p>

<p>계획된 백로그 아이템에 관한 릴리스 일정을 수립할 수 있다.</p>

<p>일정이 잡힌 백로그 아이템은 스프린트로 커밋할 수 있다.</p>

<p>첫 번째 시도: 큰 클러스터의 애그리게잇</p>

<p>제품이 ~를 포함한다.</p>

<p>컴포지션 VS 객체 그래프</p>

<p>포함 VS (상호) 연결</p>

<p>도메인 로직</p>

<p>백로그 항목을 스프린트로 커밋하면, 이를 시스템에서 제거하도록 허용해선 안 된다.</p>

<p>스프린트가 백로그 항목을 커밋하면, 이를 시스템에서 제거하도록 허용해선 안 된다.</p>

<p>릴리스가 백로그 항목의 일정을 수립하면, 이를 시스템에서 제거하도록 허용해선 안 된다.</p>

<p>백로그 항목의 릴리스 일정을 수립하면, 이를 시스템에서 제거하도록 허용해선 안 된다.</p>

<p>class Product {</p>

<p>private Set  backlogItems ;</p>

<p>private String description ;</p>

<p>private String name ;</p>

<p>private ProductId productId ;</p>

<p>private Set  releases ;</p>

<p>private Set  sprints ;</p>

<p>private TenantId tenantId ;</p>

<p>}</p>

<p>아주 큰 애그리게잇으로 모델링된 Product</p>

<p>Product와는 별도의 애그리게잇 타입으로 모델린된 연관된 개념들</p>

<p>큰 애그리게잇으로 모델링하다보면 변경에 취약해져서 업데이트 상황에서 버전 충돌이 발생할 가능성이 커진다. 위를 예시로 두면 한 명이 backlogItem을 변경하고 다른 한 명이 Spring를 변경할 시 직적접 연관이 없음에도 불구하고 버전 충돌이 발생해서 업데이트가 실패할 확률이 커진다. (애그리게잇의 크기가 커짐에 따라서 충돌 확률도 더 커짐)</p>

<p>두 번째 시도: 다수의 애그리게잇</p>

<p>하나의 큰 애그리게잇 상 Product.java</p>

<p>class Product {</p>

<p>public void planBacklogItem (</p>

<p>String summary , String category , BacklogItemType type , StoryPorints storyPoints ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>public void scheduleRelease (</p>

<p>String name , String description , Date begins , Date ends ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>public void scheduleSprint (</p>

<p>String name , String goals , Date begins , Date ends ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>}</p>

<p>여러 개로 분리된 애그리게잇 상 Product.java</p>

<p>class Product {</p>

<p>public BacklogItem planBacklogItem (</p>

<p>String summary , String category , BacklogItemType type , StoryPorints storyPoints ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>public Release scheduleRelease (</p>

<p>String name , String description , Date begins , Date ends ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>public Sprint scheduleSprint (</p>

<p>String name , String goals , Date begins , Date ends ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>}</p>

<p>일종의 factory 메서드로써 동작한다.</p>

<p>Product *Srvice 예시</p>

<p>@Service</p>

<p>class ProductBacklogItemService {</p>

<p>@Transactional</p>

<p>public void planProductBacklogItem (</p>

<p>String tenantId , String productId</p>

<p>String summary , String category</p>

<p>String backlogItemType , String storyPoints ) {</p>

<p>Product product =</p>

<p>productRepository . producetOfId (</p>

<p>new TenantId ( tenantId ),</p>

<p>new ProductId ( productId ));</p>

<p>BacklogItem plannedBacklogItem =</p>

<p>product . planBacklogItem (</p>

<p>summary , category ,</p>

<p>BacklogItemType . valueOf ( aBacklogItemType ),</p>

<p>StoryPoints . valueOf ( stroyPoints ));</p>

<p>backlogItemRepository . add ( plannedBacklogItem );</p>

<p>}</p>

<p>...</p>

<p>}</p>

<p>이와 같이 우린 밖으로 빼서 모델링함으로써(Modeling it away) 트랜잭션 실패 문제를 해결했다. 이제 BacklogItem , Release , Sprint 등의 인스턴스가 사용자의 요청에 따라 얼마든지 동시적으로 안전하게 생성될 수 있다.</p>

<p>그러나 큰 애그리게잇을 조금 다듬어서 동시성 문제를 해결할 수도 있을지도 모른다. 하이버네이트 매핑에서 optmistic-lock 옵셥을 false 로 설정해 트랜잭션 실패가 도미노 처럼 전달되는 상황을 피할 수 있다.</p>

<p>규칙: 진짜 고장자(invariant)를 일관성 경계 안에 모델링하라</p>

<p>*중요한 것은 진짜 고정자를 이해하는 것이다.</p>

<p>고장자(invariant) : 일관성(트랜잭션 일관성)을 유지해야만 한다는 비즈니스 규칙</p>

<p>트랜잭션 일관성 : 동기적, 원자적</p>

<p>결과적 일관성 : 비동기적</p>

<p>한 트랜잭션에 한 애그리게잇만 인스턴스만 포함 : 이는 너무 가혹한 것 같다.</p>

<p>규칙: 작은 애그리게잇으로 설계하라</p>

<p>이 Product 모델에선 다양한 기본 오퍼레이션이 수행될 동안 큰 컬랙션을 여럿 가져오게 된다.</p>

<p>이 큰 클러스터 애그리게잇은 성능이나 확장성이 절대로 좋을 수 없다. 이는 실패로 이어지는 악몽이 될 뿐이다. 거짓 고정자와 컴포지션적 편의성이 설계를 주도했기 때문에 시작부터 문제가 있었으며, 트랜잭션의 종료, 성능, 확장성의 측면에서 안 좋은 영향을 미쳤다.</p>

<p>작은 애그리게잇은? 다른 대상과 일관성을 유지</p>

<p>변경이 되면 엔터티</p>

<p>대치가 되면 값 객체 : 생각보다 상당히 많은 개념이 값 객체로 대치된다.</p>

<p>파생 금융상품 부문에서 약 70% 애그리게잇이 단 하나의 루트 엔터티로 구성된다.</p>

<p>작은 애그리게잇은</p>

<p>성능이 좋음</p>

<p>확장성이 좋음</p>

<p>트랜잭션이 성공할 가능성이 크다</p>

<p>유스케이스를 전부 믿지는 말라</p>

<p>하나의 유스케이스가 여러 트랜잭션을 발생 시킨다면 의심해 보자</p>

<p>이런 경우에서 결과적 일관성을 통해서 문제를 해결할 수 있다. + 지연 업데이트</p>

<p>물론 하나의 유스케이스가 하나의 트랜잭션일 필요는 없다.</p>

<p>규칙: ID로 다른 애그리게잇을 참조하라</p>

<p>객체 그래프가 연결되어 있다고 해서 같은 애그리게잇은 아니다. 그저 다른 애그리게잇을 연결했을 뿐이다.</p>

<p>여기도 결국 결과적 일관성 으로 이어진다.</p>

<p>애그리게잇 ID 참조를 통해 서로 함께 동작하도록 해보자</p>

<p>ID를 통해 경계 밖과 연결을 추론할 수 있는 BacklogItem 애그리게잇</p>

<p>class BacklogItem {</p>

<p>private ProductId productId ;</p>

<p>}</p>

<p>모델 탐색</p>

<p>객체 그래프 탐색과는 다르지만 리파지토르 와 ID 가 있으면 연관 모델을 탐색할 수 있다. : 단전될 도메인 모델(Disconnected Domain Model)</p>

<p>@Service</p>

<p>class ProductBacklogItemService {</p>

<p>@Transactional</p>

<p>public void assignTeaMemberToTask (</p>

<p>String aTenantId ,</p>

<p>String aBacklogItemId ,</p>

<p>String aTaskId ,</p>

<p>String aTeamMemberId ) {</p>

<p>BacklogItem backlogItem =</p>

<p>backlogItemRepository . findById (</p>

<p>new TenantId ( aTenantId ), new BacklogItemId ( aBacklogItemId ));</p>

<p>Team ofTeam =</p>

<p>teamRepository . findById (</p>

<p>backlogItem . tenantId (), backlogItem . teamId ());</p>

<p>backlogItem . assignTeamMemberToTask (</p>

<p>new TeamMemberId ( aTeamMemberId ), ofTeam , new TaskId ( aTaskId ));</p>

<p>}</p>

<p>}</p>

<p>확장성과 분산</p>

<p>ID 참조를 이용하게 되면 같은 영속화 플랫폼을 사용하지 않고 샤딩과 같은 확장을 통해서 일부 애그리게잇을 손쉽게 확장할 수 있다.</p>

<p>예를 들면 어떤 애그리게잇은 DB를 사용하고 연관되는 다른 애그리게잇은 NoSql을 사용할 수 있다.</p>

<p>도메인 이벤트를 통해서 외부 바운디드 컨텍스트로 분산처리를 더 가속화할 수 있다.</p>

<p>역시나 중요한 것은 결과적 일관성 이다.</p>

<p>규칙: 경계의 밖에서 결과적 일관성을 사용하라</p>

<p>결과적 일관성과 지연 시간 = 도메인 이벤트 발행</p>

<p>동시성 이슈로 인해서 발행된 이벤트 구독이 실패하면? 메시징 매커니즘을 통해서 Retry! > 이것은 쉽지가 않은 것 같다.</p>

<p>누가 해야 하는 일인지 확인하자</p>

<p>데이터의 일관성을 보장하는 주체가 유스케이스를 수행하는 사용자의 일인지를 질문해보자.</p>

<p>만약 그렇다면, 다른 애그리게잇의 규칙들은 고수하는 가운데 트랜잭션을 통해 일관성을 보장하도록 하자.</p>

<p>만약, 다른 사용자나 시스템이 해야 할 일이라면 결과적 일관성을 선택하자.</p>

<p>규칙을 어겨야하는 이유</p>

<p>첫 번째 이유: 사용자 인터페이스의 편의</p>

<p>두 번째 이유: 기술적 매커니즘의 부족</p>

<p>세 번째 이유: 글로벌 트랜잭션</p>

<p>개인적으로 안티패턴. 결과적 일관성을 사용하자</p>

<p>네 번째 이유: 쿼리 성능</p>

<p>캐싱을 통해서 어느정도 해결할 수 있다.</p>

<p>발견을 통해 통찰 얻기</p>

<p>Skip</p>

<p>구현</p>

<p>고유 ID와 루트 엔터리를 생성하라</p>

<p>값 객체 파트를 선호하라</p>

<p>‘데메테르 법칙’과 ‘묻지 말고 시켜라’를 사용하기</p>

<p>데메테르 법칙 : 정보은닉</p>

<p>묻지 말고 시켜라 : 정보은닉 + 응집력</p>

<p>낙관적 동시성</p>

<p>애그리게잇 루트에 버전을 통한 낙관적 락 기법</p>

<p>@Version : JPA를 이용하면 이 선언만으로도 낙관적 락 기법을 사용할 수 있다.</p>

<p>@Entity</p>

<p>@Table ( name = "orders" )</p>

<p>public class Order {</p>

<p>@Id</p>

<p>private Long id ;</p>

<p>@Version</p>

<p>private int version ;</p>

<p>private String description ;</p>

<p>}</p>

<p>의존성 주입을 피하라</p>

<p>애그리게잇에 서비스나 리파지토리를 주입하지 마라</p>

<p>마무리</p>

<p>가능하면 작은 애그리게잇으로 설계하자</p>

<p>일관성 경계, 트랜잭션, 고정자가 중요</p>

<p>객체 그래프 참조 VS ID 참조</p>

<p>경계 외부에서는 결과적 일관성</p>

<p>IDDD 10장. 애그리게잇 was originally published by MJ at DevOOOOOOOOP on June 05, 2018.</p>

<p>source : http://redutan.github.io/2018/06/05/IDDD-chapter10</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>JPA에서 Value Object Collection 3가지 구현</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/05/000917.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.917</id>

    <published>2018-05-29T14:55:29Z</published>
    <updated>2018-05-29T14:55:29Z</updated>

    <summary>동기 팀 내에서 IDDD(Implementing Domain-Driven Design) 스터디 중 값 객체 Collection을 ORM(hibernate)을 이용하여 구현하는 예제 를 확인했습니다. 그러던 중 이게 아주 과거 hibernate xml 구성 기준이어서 현재 JPA(Sprin Data JPA)에서는 어떻게 구현되는지 궁금 해 하던 @동묘 가 저에게 직접 구현을...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>동기</p>

<p>팀 내에서 IDDD(Implementing Domain-Driven Design) 스터디 중 값 객체 Collection을 ORM(hibernate)을 이용하여 구현하는 예제 를 확인했습니다.</p>

<p>그러던 중 이게 아주 과거 hibernate xml 구성 기준이어서 현재 JPA(Sprin Data JPA)에서는 어떻게 구현되는지 궁금 해 하던 @동묘 가 저에게 직접 구현을 보고 싶다고 해서 포스팅 하게 되었습니다.</p>

<p>구현</p>

<p>3가지 구현 방법</p>

<p>Single Column</p>

<p>Entity</p>

<p>Join Table</p>

<p>예시 도메인</p>

<p>그룹은 애그리게잇 루트(엔터티)입니다.</p>

<p>그룹맴버는 값 객체입니다.</p>

<p>한 그룹에는 여러 그룹맴버가 있습니다. (Group#groupMembers )</p>

<p>그룹과 그룹맴버는 한 애그리게잇으로 묶입니다.</p>

<p>Many Values Serialized into a Single Column</p>

<p>groups.group_members 에 그룹맴버들 객체를 직렬화해서 저장합니다. 여기에서는 varchar(4000) 데이터타입으로써 JSON으로 직렬화 하겠습니다.</p>

<p>Java</p>

<p>GroupMember.java</p>

<p>@Embeddable</p>

<p>@Value</p>

<p>public class GroupMember {</p>

<p>private String name ;</p>

<p>@Enumerated ( EnumType . STRING )</p>

<p>private GroupMemberType type ;</p>

<p>// For JPA</p>

<p>GroupMember () {</p>

<p>this . name = null ;</p>

<p>this . type = null ;</p>

<p>}</p>

<p>// For Jackson</p>

<p>@JsonCreator</p>

<p>public GroupMember ( @JsonProperty ( "name" ) String name ,</p>

<p>@JsonProperty ( "type" ) GroupMemberType type ) {</p>

<p>this . name = name ;</p>

<p>this . type = type ;</p>

<p>}</p>

<p>}</p>

<p>Group.java</p>

<p>@Entity</p>

<p>@Table ( name = "GROUPS" )</p>

<p>@Getter</p>

<p>@EqualsAndHashCode</p>

<p>@ToString</p>

<p>@NoArgsConstructor ( access = AccessLevel . PACKAGE )</p>

<p>public class Group {</p>

<p>@Id</p>

<p>@GeneratedValue</p>

<p>private Long groupId ;</p>

<p>private String description ;</p>

<p>private String name ;</p>

<p>/**</p>

<p>* ORM과 한 열로 직렬화되는 여러 값 : ORM and Many Values Serialized into a Single Column</p>

<p>*/</p>

<p>@Convert ( converter = GroupMembersConverter . class )</p>

<p>@Column ( name = "GROUP_MEMBERS" , length = 4000 )</p>

<p>private Set  group1Members = new HashSet >();</p>

<p>...</p>

<p>}</p>

<p>GroupMembersConverter.java</p>

<p>@Converter</p>

<p>public class GroupMembersConverter implements AttributeConverter , String > {</p>

<p>private ObjectMapper om = new ObjectMapper ();</p>

<p>@Override</p>

<p>public String convertToDatabaseColumn ( Set  attribute ) {</p>

<p>return om . writeValueAsString ( attribute );</p>

<p>}</p>

<p>@Override</p>

<p>public Set  convertToEntityAttribute ( String dbData ) {</p>

<p>return om . readValue ( dbData , new TypeReference >() { });</p>

<p>}</p>

<p>}</p>

<p>SQL</p>

<p>Schema</p>

<p>create table groups (</p>

<p>group_id bigint not null ,</p>

<p>description varchar ( 255 ),</p>

<p>group_members varchar ( 4000 ), /* !!! */</p>

<p>name varchar ( 255 ),</p>

<p>primary key ( group_id )</p>

<p>);</p>

<p>Insert</p>

<p>insert into groups (</p>

<p>description , group_members , name , group_id</p>

<p>) values (</p>

<p>? , ? , ? , ?</p>

<p>);</p>

<p>Many Values Backed by a Database Entity</p>

<p>실질적으로는 Entity처럼 DB 스키마를 구성 하나 실제 객체지향세계(ex:Java Application)에서는 값 객체로 보이게 구현</p>

<p>이를 위해서 상속을 이용해서 식별자 속성을 은닉 시키는 것이 구현의 핵심</p>

<p>Java</p>

<p>IdentifiedValueObject.java</p>

<p>@MappedSuperclass</p>

<p>@NoArgsConstructor ( access = AccessLevel . PROTECTED )</p>

<p>public abstract class IdentifiedValueObject {</p>

<p>@Id</p>

<p>@GeneratedValue</p>

<p>@Getter ( AccessLevel . PACKAGE )</p>

<p>@Setter ( AccessLevel . PACKAGE )</p>

<p>private Long id ; // 패키지 접근제어를 통해서 식별자 은닉. 단, hibernate는 접근 가능</p>

<p>}</p>

<p>GroupMember.java</p>

<p>@Entity</p>

<p>@Table ( name = "GROUP_MEMBERS" )</p>

<p>@Value</p>

<p>@EqualsAndHashCode ( callSuper = false )</p>

<p>public class GroupMember extends IdentifiedValueObject {</p>

<p>private String name ;</p>

<p>@Enumerated ( EnumType . STRING )</p>

<p>private GroupMemberType type ;</p>

<p>// For JPA</p>

<p>GroupMember () {</p>

<p>this . name = null ;</p>

<p>this . type = null ;</p>

<p>}</p>

<p>}</p>

<p>Group.java</p>

<p>public class Group {</p>

<p>...</p>

<p>/**</p>

<p>* ORM과 데이터베이스 엔터티로 지원되는 여러 값 : ORM and Many Values Backed by a Database Entity</p>

<p>*/</p>

<p>@OneToMany ( cascade = CascadeType . ALL , orphanRemoval = true ) // Aggregate Root 를 위한 일관성 설정</p>

<p>@JoinColumn ( name = "GROUP_ID" )</p>

<p>private Set  groupMembers = new HashSet >();</p>

<p>...</p>

<p>}</p>

<p>SQL</p>

<p>Schema</p>

<p>create table groups (</p>

<p>group_id bigint not null ,</p>

<p>description varchar ( 255 ),</p>

<p>name varchar ( 255 ),</p>

<p>primary key ( group_id )</p>

<p>);</p>

<p>create table group_members (</p>

<p>id bigint not null , // PK !!</p>

<p>name varchar ( 255 ),</p>

<p>type varchar ( 255 ),</p>

<p>group_id bigint ,</p>

<p>primary key ( id )</p>

<p>)</p>

<p>alter table group_members</p>

<p>add constraint fk_groups_group_members</p>

<p>foreign key ( group_id ) references groups ;</p>

<p>Insert</p>

<p>insert into groups ( description , name , group_id ) values ( ? , ? , ? )</p>

<p>insert into group_members ( name , type , id ) values ( ? , ? , ? )</p>

<p>insert into group_members ( name , type , id ) values ( ? , ? , ? )</p>

<p>update group_members set group_id =? where id =? /* Update ?! */</p>

<p>update group_members set group_id =? where id =?</p>

<p>일반적으로 가장 무난하며, IDDD 책에서는 저자가 가장 추천한 방식</p>

<p>Many Values Backed by a Join Table</p>

<p>group_members 을 테이블로 분리하는데 이 테이블은 PK가 없이 groups 의 PK를 FK로 가지는 Join Table로 구현</p>

<p>Java</p>

<p>Group.java</p>

<p>public class Group {</p>

<p>@Id</p>

<p>@GeneratedValue</p>

<p>private Long groupId ;</p>

<p>private String description ;</p>

<p>private String name ;</p>

<p>/**</p>

<p>* ORM과 조인 테이블로 지원되는 여러 값 : ORM and Many Values Backed by a Join Table</p>

<p>*/</p>

<p>@ElementCollection</p>

<p>@CollectionTable ( name = "GROUP_MEMBERS" , joinColumns = @JoinColumn ( name = "GROUP_ID" ))</p>

<p>private Set  groupMembers = new HashSet >();</p>

<p>...</p>

<p>}</p>

<p>SQL</p>

<p>Schema</p>

<p>create table groups (</p>

<p>group_id bigint not null ,</p>

<p>description varchar ( 255 ),</p>

<p>name varchar ( 255 ),</p>

<p>primary key ( group_id )</p>

<p>);</p>

<p>create table group_members ( /* No PK */</p>

<p>group_id bigint not null ,</p>

<p>name varchar ( 255 ),</p>

<p>type varchar ( 255 )</p>

<p>);</p>

<p>alter table group_members</p>

<p>add constraint fk_groups_group_members</p>

<p>foreign key ( group_id ) references groups ;</p>

<p>Insert</p>

<p>insert into groups ( description , name , group_id ) values ( ? , ? , ? );</p>

<p>insert into group_members ( group_id , name , type ) values ( ? , ? , ? );</p>

<p>insert into group_members ( group_id , name , type ) values ( ? , ? , ? );</p>

<p>이슈</p>

<p>값 객체 Collection에 새로운 값이 추가되거나 기존 값이 변경될 시 All Delete and Re-insert</p>

<p>@ElementCollection 을 통해 변경이 발생할 시, 전체를 지우고 다시 입력하는 이슈가 있음.</p>

<p>이를 완화시키기 위해서 @OrderColumn 을 추가하는 방법이 있긴하나 완벽하지는 않음</p>

<p>public class Group {</p>

<p>...</p>

<p>@ElementCollection</p>

<p>@CollectionTable ( name = "GROUP_MEMBERS" , joinColumns = @JoinColumn ( name = "GROUP_ID" ))</p>

<p>@OrderColumn // !!!</p>

<p>private Set  groupMembers = new HashSet >();</p>

<p>...</p>

<p>}</p>

<p>Summary</p>

<p>Single Column</p>

<p>Entity</p>

<p>Join Table</p>

<p>Reference</p>

<p>소스코드 : https://github.com/redutan/ddd-values</p>

<p>Implementing Domain-Driven Design. Vaughn Vernon</p>

<p>자바 ORM 표준 JPA 프로그래밍. 김영한</p>

<p>http://kwonnam.pe.kr/wiki/java/jpa/elementcollection</p>

<p>JPA에서 Value Object Collection 3가지 구현 was originally published by MJ at DevOOOOOOOOP on May 29, 2018.</p>

<p>source : http://redutan.github.io/2018/05/29/ddd-values-on-jpa</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>IDDD 9장. 모듈</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/05/000909.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.909</id>

    <published>2018-05-28T04:54:15Z</published>
    <updated>2018-05-28T04:54:15Z</updated>

    <summary>Java: 패키지 C#: 네임스페이스 Roby: 모듈 모듈로 설계하기 모듈 : 도메인 객체의 컨테이너 규칙 모델링의 개념에 맞춰 모듈을 설계하자 유비쿼터스 언어에 맞춰 모듈을 명명하자 모델에서 사용하는 일반적인 컴포넌트 타입이나 패턴에 따라서 기계적으로 모듈을 생성하지 말자 느슨하게 결합된 모듈을 설계하자. 결합이...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>Java: 패키지</p>

<p>C#: 네임스페이스</p>

<p>Roby: 모듈</p>

<p>모듈로 설계하기</p>

<p>모듈 : 도메인 객체의 컨테이너</p>

<p>규칙</p>

<p>모델링의 개념에 맞춰 모듈을 설계하자</p>

<p>유비쿼터스 언어에 맞춰 모듈을 명명하자</p>

<p>모델에서 사용하는 일반적인 컴포넌트 타입이나 패턴에 따라서 기계적으로 모듈을 생성하지 말자</p>

<p>느슨하게 결합된 모듈을 설계하자.</p>

<p>결합이 필요하다면 짝이 되는 모듈 사이에서 비순환적 의존성이 형성되도록 노력하자</p>

<p>자식 모듈과 부모 모듈 사이에 규칙은 느슨하게 하자</p>

<p>모듈을 모델의 정적인 개념에 따라 만들지 말고, 모듈이 담고 있는 객체에 맞추도록 하자</p>

<p>주방의 서랍에 식기류가 포크와 나이프와 스푼별로 잘 정리돼 있음</p>

<p>기본 모듈 명명 규칙</p>

<p>Java: com.saasovation</p>

<p>C#: SaaSOvation</p>

<p>모델을 위한 모듈 명명 규칙</p>

<p>바운디드 컨텍스트</p>

<p>com.saasovation.identityaccess</p>

<p>com.saasovation.collovoration</p>

<p>com.saasovation.agilepm</p>

<p>모듈 구성 예시</p>

<p>com.saasovation.identityaccess</p>

<p>domain.model</p>

<p>결론은 여러분 팀의 몫이다.</p>

<p>애자일 프로젝트 관리 컨텍스트의 모듈</p>

<p>com.saasovation.agilepm</p>

<p>domain</p>

<p>model</p>

<p>product</p>

<p>backlogitem</p>

<p>release</p>

<p>sprint</p>

<p>tenant</p>

<p>team</p>

<p>이 팀은 모듈 사이의 결합도 문제보다 정리 에 중점을 뒀다.</p>

<p>다른 계층 속의 모듈</p>

<p>계층</p>

<p>모듈</p>

<p>비고</p>

<p>사용자 인터페이스</p>

<p>com.saasovation.agilepm.resources</p>

<p>ui</p>

<p>애플리케이션</p>

<p>com.saasovation.agilepm.application</p>

<p>도메인</p>

<p>com.saasovation.agilepm.domain</p>

<p>인프라</p>

<p>com.saasovation.agilepm.infrastructure</p>

<p>adapter</p>

<p>바운디드 컨텍스트보다 모듈</p>

<p>모듈은 응집력이 낮은 경우 분리하기 위한 컨테이너이고, 바운디드 컨텍스트는 그저 경계일 뿐이다.</p>

<p>어짜피 모듈은 상향식(bottom-up)으로 설계하게된다.</p>

<p>모듈 내의 컴포넌트들에 따라서 나눠질 수도 합쳐질 수도 있다. 중요한 것은 도메인 로직과 유비쿼터스 언어에 따르는 것이다.</p>

<p>마무리</p>

<p>유비쿼터스 언어를 표현한다.</p>

<p>모듈 설계의 예시!!</p>

<p>기계적인 모듈 설계는 창의성을 방해한다.</p>

<p>바운디드 컨텍스트 분리보다 모듈 사용이 먼저다.</p>

<p>IDDD 9장. 모듈 was originally published by MJ at DevOOOOOOOOP on May 28, 2018.</p>

<p>source : http://redutan.github.io/2018/05/28/IDDD-chapter09</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>IDDD 8장. 도메인 이벤트</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/05/000893.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.893</id>

    <published>2018-05-23T16:18:59Z</published>
    <updated>2018-05-23T16:18:59Z</updated>

    <summary>Publish-Subscribe 언제 그리고 왜 도메인 이벤트를 사용할까? 도메인 내 어떤 사건이 발생했을 때 한 트랜잭션에는 한 애그리게잇만 커밋 이벤트의 모델링 어떤 명령에서 어떤 사건이 발생했었음 Command : BacklogItem#commitTo(Spring) Event : BacklogItemCommitted 백로그 항목이 커밋됐다.(과거형) package com . saasovation . agilepm...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>Publish-Subscribe</p>

<p>언제 그리고 왜 도메인 이벤트를 사용할까?</p>

<p>도메인 내 어떤 사건이 발생했을 때</p>

<p>한 트랜잭션에는 한 애그리게잇만 커밋</p>

<p>이벤트의 모델링</p>

<p>어떤 명령에서 어떤 사건이 발생했었음</p>

<p>Command : BacklogItem#commitTo(Spring)</p>

<p>Event : BacklogItemCommitted</p>

<p>백로그 항목이 커밋됐다.(과거형)</p>

<p>package com . saasovation . agilepm . domain . model . product ;</p>

<p>@Value</p>

<p>class BacklogItemCommitted implements DomainEvent {</p>

<p>Date occurredOn ;</p>

<p>BacklogItemId backlogItemId ;</p>

<p>SpringId committedToSprintId ;</p>

<p>TenantId tenantId ;</p>

<p>}</p>

<p>package com . saasovation . agilepm . domain . model ;</p>

<p>interface DomainEvent {</p>

<p>Date occurredOn ();</p>

<p>}</p>

<p>추가사항</p>

<p>멱등성</p>

<p>더 풍부한 상태 전달 (이벤트 소싱!)</p>

<p>애그리게잇의 특성과 함께하기</p>

<p>이벤트를 애그리게잇을 통해서 영속화</p>

<p>식별자</p>

<p>이벤트를 애그리게잇으로 모델링하면 식별자가 필요하다.</p>

<p>도메인 이벤트를 바운디드 컨텍스트 외부로 발행 시 식별자가 필요(With rabbitmq)</p>

<p>외부 구독자 입장에서는 멱등성 관리를 위해서 식별자를 할당할 수 있음</p>

<p>equals 로 일정 부분 해결할 수도 있다 (in 로컬 바운디드 컨텍스트)</p>

<p>도메인 모델에서 이벤트 발행하기</p>

<p>Light-Weight Publish-Subscribe</p>

<p>Reference : https://github.com/redutan/redutan.github.io/wiki/Domain-Event-on-Springframework</p>

<p>발행자</p>

<p>class BacklogItem extends AbstractAggregateRoot  {</p>

<p>void commitTo ( Sprint spint ) {</p>

<p>// Some domain logic</p>

<p>super . registerEvent ( new BacklogItemCommitted (</p>

<p>this . tenantId (),</p>

<p>this . backlogItemId (),</p>

<p>this . sprintId ()</p>

<p>));</p>

<p>}</p>

<p>}</p>

<p>class BacklogItemService { // Application Service</p>

<p>@TransactionalEventListener</p>

<p>void commitBacklogItem (...) {</p>

<p>backlogItem . commitTo ( sprint ); // Publish BacklogItemCommitted event</p>

<p>}</p>

<p>}</p>

<p>구독자</p>

<p>class BacklogItemService { // Application Service</p>

<p>@TransactionalEventListener</p>

<p>void handleBacklogItemCommitted ( BacklogItemCommitted event ) {</p>

<p>// BacklogItemCommitted 구독 후 처리</p>

<p>}</p>

<p>}</p>

<p>중요한 것은 결과적 일관성</p>

<p>뉴스를 원격 바운디드 컨텍스트로 전파하기</p>

<p>시스템 간 결과적 일관성 확보</p>

<p>메시징 인프라의 일관성</p>

<p>구현방법</p>

<p>도메인 모델과 메시지 인프라 저장소 공유</p>

<p>원격 DB with XA</p>

<p>이벤트 저장소</p>

<p>자치 서비스와 시스템</p>

<p>자치 서비스 : 이벤트를 통해서 시스템 간 결합도(독립성!)를 줄이는 기법 (No-RPC)</p>

<p>자치 서비스의 단위는 바운디드 컨텍스트가 되면 좋은 것 같다.</p>

<p>지연 시간 허용</p>

<p>결과적 일관성 을 위해서</p>

<p>도메인 별로 그 때 그 때 달라요.</p>

<p>시스템의 허용치를 만족시키면서도 잘 수행되도록 아키텍처 품질을 높여야 한다.</p>

<p>이벤트 저장소</p>

<p>이벤트의 상태를 유지하기 위해서 저장하는 것이 요구되는 경우가 많다.</p>

<p>@Aspect</p>

<p>class IdentityAccessEventProcessor {</p>

<p>@Before ( "execution(* com.saasovation.identityaccess.application.*.**..))" )</p>

<p>public void listen () {</p>

<p>DomainEventPublisher . instance ()</p>

<p>. subscribe ( new DomainEventSubscriber () {</p>

<p>public void handleEvent ( DomainEvent aDomainEvent ) {</p>

<p>store ( aDomainEvent );</p>

<p>}</p>

<p>public Class  subscribedToEventType () {</p>

<p>return DomainEvent . class ; // 모든 도메인 이벤트</p>

<p>}</p>

<p>});</p>

<p>}</p>

<p>private void store ( DomainEvent aDomainEvent ) {</p>

<p>EventStore . instance (). append ( aDomainEvent );</p>

<p>}</p>

<p>}</p>

<p>class StoreEvent {</p>

<p>void append ( DomainEvent aDomainEvent ) {</p>

<p>String eventSerializatoin =</p>

<p>EventStore . objectSerializer (). serialize ( aDomainEvent );</p>

<p>StoredEvent storedEvent =</p>

<p>new StoredEvent (</p>

<p>aDomainEvent . getClass (). getName (),</p>

<p>aDomainEvent . occuredOn (),</p>

<p>eventSerialization );</p>

<p>this . session (). save ( storedEvent );</p>

<p>this . setStoredEvent ( storedEvent );</p>

<p>}</p>

<p>}</p>

<p>CREATE TABLE tbl_stored_event (</p>

<p>event_id int ( 11 ) NOT NULL auto_increment ,</p>

<p>event_body varchar ( 65000 ) NOT NULL ,</p>

<p>occurred_on datetime NOT NULL ,</p>

<p>type_name varchar ( 100 ) NOT NULL ,</p>

<p>PRIMARY KEY ( event_id )</p>

<p>)</p>

<p>저장된 이벤트의 전달을 위한 아키텍처 스타일</p>

<p>레스트품 리소스로서 알림 발행하기</p>

<p>이벤트를 REST/WEB API로 발행한다. (이벤트 아이디나 애그리게잇 아이디를 전달)</p>

<p>이벤트 저장소를 통해서 조회하거나, 애그리게잇을 직접 조회한다.</p>

<p>구독 측에서 발행측에 다시 상세 이벤트 정보를 조회한 후 처리한다.</p>

<p>메시징 미들웨어를 통한 알림 발행</p>

<p>메시징 미들웨어를 통해서 이벤트를 발행한다.</p>

<p>메시징 미들웨어를 구독한 구독 측에서 발행 측의 상세 이벤트 정보를 조회한 후 처리 한다.</p>

<p>발행과 구독은 exchange나 queue 개념으로 연결된다.</p>

<p>구현</p>

<p>Skip</p>

<p>멱등 수신자 처리가 중요하다 : At least once</p>

<p>멱등성 : 오퍼레이션이 두 번 이상 수행되어도, 한 번만 수행했을 때와 같은 결과에 이르는 동작을 의미</p>

<p>궁극적으로 이벤트를 추적해야하는 경우가 생기기 때문에 이벤트 저장 기능이 거의 필수적으로 요구된다.</p>

<p>그리고 추적 일관성을 위해서 이벤트 저장은 도메인 로직과 트랜잭션으로 묶이는 것이 중요하다.</p>

<p>마무리</p>

<p>이벤트 만의 고유 식별자가 요구된다.</p>

<p>이벤트 저장소도 필요</p>

<p>어짜피 발행-구독!</p>

<p>멱등성 또는 중복 발행 or 수신 제거 확보</p>

<p>IDDD 8장. 도메인 이벤트 was originally published by MJ at DevOOOOOOOOP on May 24, 2018.</p>

<p>source : http://redutan.github.io/2018/05/24/IDDD-chapter08</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>IDDD 4장. 아키텍처</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/05/000858.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.858</id>

    <published>2018-05-10T10:08:23Z</published>
    <updated>2018-05-10T10:08:23Z</updated>

    <summary>실제 요구(도메인)가 아키텍처 스타일과 패턴의 사용을 유도해야 한다. 도메인이 기술 보다 먼저다. 성공한 CIO와의 인터뷰 Server-Client Architecture 계층형 아키텍처 DIP, QP, PSA, DDD-Lite 헥사고날 아키텍처 To Mobile, Cloud CQRS Materialized Views Event-Driven Architecture Pipeline + Filter Saga 패턴 Long-lived transaction...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>실제 요구(도메인)가 아키텍처 스타일과 패턴의 사용을 유도해야 한다.</p>

<p>도메인이 기술 보다 먼저다.</p>

<p>성공한 CIO와의 인터뷰</p>

<p>Server-Client Architecture</p>

<p>계층형 아키텍처</p>

<p>DIP, QP, PSA, DDD-Lite</p>

<p>헥사고날 아키텍처</p>

<p>To Mobile, Cloud</p>

<p>CQRS</p>

<p>Materialized Views</p>

<p>Event-Driven Architecture</p>

<p>Pipeline + Filter</p>

<p>Saga 패턴</p>

<p>Long-lived transaction as a sequence of subtransactions.</p>

<p>In a distributed system</p>

<p>이벤트 소싱</p>

<p>모든 변경을 추적 (ex: 보안 감사 등)</p>

<p>이러한 아키텍처 덕분에 결국 회사에 돈이 된다</p>

<p>계층</p>

<p>그림 4.1 DDD가 적용된 전통적인 계층 아키텍처</p>

<p>[출처] https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/</p>

<p>도메인 모델과 비즈니스 로직을 도메인 계층에 격리</p>

<p>하위 계층에만 의존 - 아래에서 위쪽으로 직접 참조 불가 (하지만 Observer 사용 가능)</p>

<p>느슨한 연결 : UI가 애플리케이션(바로 하위) 뿐만 아니라 도메인이나 인프라에도 의존 가능</p>

<p>UI 계층</p>

<p>View나 API 제공</p>

<p>도메인 모델이 아닌 표현 모델(DTO)를 사용 추천</p>

<p>애플리케이션 계층</p>

<p>UI로 부터 매개변수를 받아 리파지토리를 사용해 애그리게잇을 획득하고, 커맨드를 위임</p>

<p>보안과 트랜젝션 담당 (일반적으로 보안을 UI로 올리는 것 같음)</p>

<p>도메인 로직 없으며 도메인 모델(애그리게잇, 도메인 서비스 등)에 위임</p>

<p>도메인 모델에서 발행한 도메인 이벤트를 구독(subscribe)</p>

<p>@Transactionl</p>

<p>void commitBackLogItemToSpring (</p>

<p>String aTanantId , String aBackLogItemId , String aSprintId ) {</p>

<p>// 재료(Aggregate) 준비</p>

<p>BacklogItem backlogItem =</p>

<p>backlogItemRepository . backlogItemOfId ( aTanantId , aBacklogItemId );</p>

<p>Sprint sprint sprintRepository . sprintOfId ( aSprintId );</p>

<p>// 커맨드 위임</p>

<p>backlogItem . commitTo ( sprint );</p>

<p>}</p>

<p>DIP</p>

<p>상위 수준의 모듈은 하위 수준 모듈에 의존해선 안된다. 둘 모두는 반드시 추상화에 의존해야 한다.</p>

<p>추상화는 세부사항에 의존해선 안 된다. 세부사항은 추상화에 의존해야 한다.</p>

<p>하위 구현 컴포넌트가 상위 콤포넌트가 정의한 인터페이스에 의존해야한다.</p>

<p>어라 그러다 보니 계층이 없어진다. 여기에 대칭성을 더하면 어떻게 될까?</p>

<p>헥사고날 또는 포트와 어댑터</p>

<p>헥사고날 아키텍처</p>

<p>[출처] http://alistair.cockburn.us/Hexagonal+architecture</p>

<p>Texi handling Hexagonal Architecture</p>

<p>[출처] https://github.com/seongminwoo/study/blob/master/7-part_series_about_microservices.md</p>

<p>헥사고날의 장점</p>

<p>기능적 요구사항에 따라 애플리케이션 내부를 설계</p>

<p>UI, Infra는 그 다음이다.</p>

<p>애플리케이션 내부가 캡슐화 된다.</p>

<p>Adapter를 통해 기술과 분리</p>

<p>서비스 지향(SOA)</p>

<p>중요한 것은 기술 보다 비즈니스(도메인) 가치가 우선해야 한다</p>

<p>REST: 표현 상태 전송</p>

<p>[출처] https://martinfowler.com/articles/richardsonMaturityModel.html</p>

<p>RESTful HTTP 서버의 주요 특징</p>

<p>Resource : URI</p>

<p>Verbs : GET, POST, PUT, DELETE, …</p>

<p>Hypermedia : 연결된 리소스를 제공. 상호작용, 클라이언트 무상태</p>

<p>RESTful HTTP 클라이언트의 주요 특징</p>

<p>Hypermedia를 바탕으로 상호 작용한다.</p>

<p>REST와 DDD</p>

<p>도메인 모델을 RESTful로 바로 노출하는 것은 좋지 않다.</p>

<p>도메인 모델의 변경이 API와 연결되기 때문에 변경에 취약해지며, 클라이언트와 호환성이 깨진다.</p>

<p>해결책</p>

<p>도메인 모델 -> 표현 모델을 조립 (추천)</p>

<p>Assembler + DTO (PoEAA)</p>

<p>각 상황 별 공유 도메인 모델 사용</p>

<p>공유커널</p>

<p>왜 REST인가</p>

<p>느슨함</p>

<p>CQRS</p>

<p>사용자가 필요로하는 데이터 뷰를 리파지토리로 쿼리하기란 어려울 수 있다.</p>

<p>CQRS = 객체 설계 원칙 + CQS</p>

<p>Command : 객체의 상태를 수정, Void 형</p>

<p>Query : 값을 반환, 수정 X</p>

<p>구현</p>

<p>애그리게잇은 오직 커맨드 메소드만 가지고 있음.(커맨드 모델)</p>

<p>쿼리를 위한 뷰 전용 모델(쿼리 모델)을 생성</p>

<p>CQRS의 영역 살펴보기</p>

<p>출처 : https://docs.microsoft.com/ko-kr/azure/architecture/guide/architecture-styles/cqrs</p>

<p>참고 : https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs</p>

<p>클라이언트와 쿼리 처리기</p>

<p>쿼리 모델(읽기 모델)</p>

<p>필요한 수 만큼 뷰를 지원하기</p>

<p>실용적으로 하라</p>

<p>데이터베이스 테이블 뷰가 오버헤드의 원인이 되지 않을까?</p>

<p>클라이언트가 커맨트 처리를 주도한다.</p>

<p>UI to Argument</p>

<p>커맨드 처리기</p>

<p>카테고리 스타일 : 1 class n methods</p>

<p>전용 스타일 : 1 class 1 method</p>

<p>커맨드 모델(쓰기 모델)은 행동을 수행한다.</p>

<p>public void commitTo ( Sprint aSprint ) {</p>

<p>...</p>

<p>DomainEventPublisher</p>

<p>. instance ()</p>

<p>. publish ( new BacklogItemCommitted (</p>

<p>this . tenant (),</p>

<p>this . backlogItemId (),</p>

<p>this . sprintId ()</p>

<p>));</p>

<p>}</p>

<p>어떤 경우든 쿼리 모델을 업데이트시키기 위해선 도메인 이벤트를 게시해야 한다.</p>

<p>이벤트 구독자가 쿼리 모델을 업데이트 한다.</p>

<p>동기도 가능하고 비동기 도 가능하다.</p>

<p>결국은 일관성이 유지되는 쿼리 모델 다루기</p>

<p>Eventually consistent</p>

<p>지연되는 뷰 데이터 동기화를 해결해야한다.</p>

<p>낙관적 업데이트 기법!</p>

<p>클라이언트에서 publish/subscribe 기법</p>

<p>결국은 동기화되는 지연시간이 문제</p>

<p>이벤트 주도 아키텍처(EDA)</p>

<p>이벤트의 생산, 감지, 소비와 이벤트에 따른 응답 등을 촉진하는 소프트웨어 아키텍처</p>

<p>From 도메인 이벤트</p>

<p>파이프와 필터</p>

<p>$ cat phone_number.txt | grep 303 | wc -1</p>

<p>Spring Cloud Data Flow</p>

<p>그림 4.8 필터를 처리하는 이벤트를 보냄으로써 파이프라인이 만들어진다.</p>

<p>[출처] http://zhangyi.farbox.com/post/coding/understand-scala-stack</p>

<p>이는 가상의 예제이자 개념적 부분을 강조했을 뿐이다. 실제 엔터프라이즈에선 큰 문제를 좀 더 작은 단계로 나누기 위해 이 패턴을 사용하며, 좀 더 쉽게 분산 처리를 이해하고 관리하도록 해준다.</p>

<p>또한 여러 시스템이 오직 자신이 할 일(도메인)만을 걱정하게 되게 해주기도 한다.</p>

<p>장기 실행 프로세스</p>

<p>컴포지트</p>

<p>애그리게잇 집합</p>

<p>이벤트</p>

<p>역시나 중요한 것은 결과적 일관성 (Eventual Consistency)</p>

<p>Saga Pattern</p>

<p>Events/Choreography</p>

<p>Rollback</p>

<p>referecne : https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/</p>

<p>이벤트 소싱</p>

<p>거의 완벽한 수준의 변경 추적</p>

<p>[출처] https://docs.microsoft.com/ko-kr/azure/architecture/patterns/event-sourcing</p>

<p>Replay : 이벤트소싱에서 이벤트를 되감아서 특정 버전 상태로 되돌리는 것</p>

<p>하지만 최신 버전 Replay는 병목의 원인</p>

<p>이를 해결하기 위해서 최신 버전의 상태를 Snapshot 으로 지정해서 최적화</p>

<p>데이터 패브릭과 그리드 기반 분산 컴퓨팅</p>

<p>분산 캐시</p>

<p>ex) hazelcast</p>

<p>데이터 복제</p>

<p>캐시 master/slave</p>

<p>복제를 통한 장애 극복</p>

<p>이벤트 유실 제거 (이벤트 publish/subscribe도 가능)</p>

<p>이벤트 주도 패브릭과 도메인 이벤트</p>

<p>For Domain Event</p>

<p>지속적 쿼리</p>

<p>For CQRS</p>

<p>분산 처리</p>

<p>For Saga 또는 배치 병렬 처리</p>

<p>마무리</p>

<p>Layerd Architecture > DIP > Hexagonal Architecture</p>

<p>SOA, REST, 분산 컴퓨팅</p>

<p>CQRS, Event Sourcing, pipe/filter, Saga</p>

<p>IDDD 4장. 아키텍처 was originally published by MJ at DevOOOOOOOOP on May 08, 2018.</p>

<p>source : http://redutan.github.io/2018/05/08/IDDD-chapter04</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>IDDD 3장. 컨텍스트 맵</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/05/000847.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.847</id>

    <published>2018-05-10T10:08:11Z</published>
    <updated>2018-05-10T10:08:11Z</updated>

    <summary>바운디드 컨텍스트 간 관계를 그리는 것으로써 해결책 공간 에 초점을 맞추가 있다. 컨텍스트 맵이 필수적인 이유 그림 3.1 추상적 도메인의 컨텍스트 맵 [출처] https://www.safaribooksonline.com/library/view/implementing-domain-driven-design/9780133039900/ch03lev1sec1.html U = 업스트림 D = 다운스트림 컨텍스트 맵 은 상호 교류하는 시스템의 목록을 제공하고, 팀 내...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>바운디드 컨텍스트 간 관계를 그리는 것으로써 해결책 공간 에 초점을 맞추가 있다.</p>

<p>컨텍스트 맵이 필수적인 이유</p>

<p>그림 3.1 추상적 도메인의 컨텍스트 맵</p>

<p>[출처] https://www.safaribooksonline.com/library/view/implementing-domain-driven-design/9780133039900/ch03lev1sec1.html</p>

<p>U = 업스트림</p>

<p>D = 다운스트림</p>

<p>컨텍스트 맵 은 상호 교류하는 시스템의 목록을 제공하고, 팀 내 의사소통의 촉매 역할을 한다.</p>

<p>프로젝트와 조직 관계</p>

<p>통합 패턴들</p>

<p>파트너십(Partnership) : 두 컨텐스트가 한 트랜젝션으로 묶임 - 2 phase commit?</p>

<p>공유 커널(Shared kernel) : 상호 의존하는 공유 모델을 관리 - 안티 패턴이라고 봄</p>

<p>고객-공급자(Customer-Supplier Development) : 업스트림(서버:공급자), 다운스트림(클라이언트:고객)로 단방향 의존 표현</p>

<p>순응주의자(Conformist) : 업스트림(서버) is King</p>

<p>부패 방지 계층(Anticorruption Layer) : 변환을 통해서 다운스트림 컨텍스트 내 순수함을 지킴 (Adapter + Translator)</p>

<p>오픈 호스트 서비스(Open Host Service) : REST/API, RPC, Socket</p>

<p>발행된 언어(Published Language) : Json, XML, Byte</p>

<p>분리된 방법(Seprate Ways) : 의존 없음</p>

<p>큰 진흙공(Big ball of mud) : 똥덩어리</p>

<p>세 가지 컨텍스트를 매핑하기</p>

<p>before</p>

<p>문제점 공간</p>

<p>분리된 핵심 을 이용</p>

<p>after</p>

<p>해결책 공간</p>

<p>대부분 순응주의자 를 많이 사용하는 것 같다.</p>

<p>상호 의존이 걸리는 partnership 도 많은 것 같다.</p>

<p>개인적으로는 고객-공급자 가 좋다.</p>

<p>일반적으로 핵심 도메인은 다운스트림 이다.</p>

<p>업스트림에서 다운스트림으로 모델 복제는 Evil 이다.</p>

<p>[출처] https://www.codeproject.com/Articles/1158628/Domain-Driven-Design-What-You-Need-to-Know-About-</p>

<p>통합 전에 ACL를 통해서 변활할 시 최소한의 속성만 있으면 된다.</p>

<p>식별자와 액세스 컨텍스트의 통합</p>

<p>중요한 것은 애자일 프로젝트 컨택스트에 식별자 도메인이 침투하지 못하게 하는 것</p>

<p>협업 컨텍스트와 통합</p>

<p>결과적 일관성이 중요하다. - 이벤트 기반 아키텍쳐</p>

<p>그렇다면 상태관리를 해야한다.</p>

<p>enum DiscussionAvailability {</p>

<p>ADD_ON_NOT_ENABLED , NOT_REQUESTED , REQUESTED , READY ;</p>

<p>}</p>

<p>@Value</p>

<p>class Discussion {</p>

<p>DiscussionAvailiability availability ;</p>

<p>DiscussionDescriptor descriptor ;</p>

<p>...</p>

<p>}</p>

<p>class Product extends Entity {</p>

<p>private Discussion discussion ;</p>

<p>...</p>

<p>}</p>

<p>Product에서 Discussion을 사용할 시 READY 인 경우에만 가능</p>

<p>협업.Calendar -> 프로젝트관리.Scheduling</p>

<p>협업.Forum -> 프로젝트관리.Discussion</p>

<p>마무리</p>

<p>OHS, PL, ACL</p>

<p>IDDD 3장. 컨텍스트 맵 was originally published by MJ at DevOOOOOOOOP on May 05, 2018.</p>

<p>source : http://redutan.github.io/2018/05/05/IDDD-chapter03</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>IDDD 1장. DDD를 시작하며</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/05/000805.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.805</id>

    <published>2018-05-10T10:07:26Z</published>
    <updated>2018-05-10T10:07:26Z</updated>

    <summary>설계는 단순히 어떻게 보이고 느껴지는가에 관한 것이 아니다. 설계는 어떻게 동장하는가에 관한 것이다. 스티브 잡스 DDD는 우리가 높은 품질의 소프트웨어 모델을 설계할 수 있도록 해준다. DDD는 전략적인 동시에 전술적(DDD-Lite)인 모델링 도구 나도 DDD를 할 수 있을까? 학습 곡선이 있다!! DDD의...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>설계는 단순히 어떻게 보이고 느껴지는가에 관한 것이 아니다. 설계는 어떻게 동장하는가에 관한 것이다.</p>

<p>스티브 잡스</p>

<p>DDD는 우리가 높은 품질의 소프트웨어 모델을 설계할 수 있도록 해준다.</p>

<p>DDD는 전략적인 동시에 전술적(DDD-Lite)인 모델링 도구</p>

<p>나도 DDD를 할 수 있을까?</p>

<p>학습 곡선이 있다!!</p>

<p>DDD의 가장 중심에 있는 원리</p>

<p>토의, 경청, 이해, 발견, 비즈니스의 가치</p>

<p>모든 지식을 중앙화하는 모든 것</p>

<p>DDD는 객체지향적 방법 으로 엔터프라이즈 애플리케이션을 해결하는 방법</p>

<p>DDD는 MSA를 지향한다. Monolithic은 지양한다.</p>

<p>시니어 개발자 : 이 조직은 내가 생각했던 것보다 파괴적 진보에 관심이 없더군요. 뭐 상관 없어요 나는 포기하지 않겠어요.</p>

<p>도메인 전문가 : 유비쿼터스 용어로 소통하자</p>

<p>내가 왜 DDD를 해야할까?</p>

<p>개발자  도메인 전문가</p>

<p>설계는 코드이며, 코드가 설계다. 설계는 어떻게 작동하는가다. - Uncle Bob도 비슷한 말을 함</p>

<p>옳은 소프트웨어 개발 접근 방식에 투자한다는 생각</p>

<p>DDD가 해줄 수 있는 일</p>

<p>도메인 전문가와 개발자는 가까운 거리에서 유비쿼터스 언어로 소통하면서 협업해야 한다.</p>

<p>기술보다는 도메인 가치가 우선이다.</p>

<p>도메인의 복잡성과 씨름하기</p>

<p>핵심 도메인과 서브 도메인</p>

<p>ex) 커머스 솔루션에서 핵심 도메인은 결제이며, 서브 도메인은 배송이다.</p>

<p>DDD를 통해서 복잡화하지 말고 단순화하라</p>

<p>Anemic Domain Model : 빈약한 도메인 모델. 속성만 표현하는 단순한 데이타 홀더. 보통 트랜잭션 스크립트 와 연결된다.</p>

<p>Rich Domain Model : 풍부한 도메인 모델. DDD를 통해서 도메인을 표현한 풍부한 행위를 가지는 모델</p>

<p>과거에는 객체 관계형 임피던스 부조화 때문에 Anemic Domain Model 을 많이 사용하게 되는데, 이제 ORM이 대중화 되어서 할만하다!!</p>

<p>왜 무기력(Anemic)증이 일어나는가?</p>

<p>절차적 사고방식의 익숙함</p>

<p>단순한 샘플코드를 참고</p>

<p>비주얼 베이직 탓 : 클릭하고 드래그 앤 드랍 하면 프로그램이 만들어짐 - 이건 좀 ….</p>

<p>Getter, Setter의 자바빈을 숨기는 여러 방법이 있었지만, 대부분 개발자는 그러려고 하지 않았거나, 왜 그렇게 해야 하는지 이해조차 하지 못했다. 온통 무기력증 이다.</p>

<p>일반적인 행위로 모든 상황(도메인 지식)을 커버하려 한다. 이것은 안티 도메인 모델이 된다.</p>

<p>코드로 말하면 Setter들의 향연이 벌어진다. 그저 데이터 홀더일 뿐 이다. -> 무기력증</p>

<p>뷰를 위한 모델은 Getter, Setter로 구성되는 것이 좋다.(DTO 패턴) 하지만 도메인 모델은 아니다.</p>

<p>p.67 p.69 코드를 보면서 반성하자.</p>

<p>DDD는 어떻게 하는가?</p>

<p>유비쿼터스 언어 : 반운디드 컨텍스트 내에서 공유된 언어. 도메인 전문가화 개발자 모두에 의해 개발되어 공유된 언어. - 서로 많이 이야기 하자.</p>

<p>ex) 간호사가 독감 백신을 표준 용량으로 환자에게 투여한다. : nurse.administerFluVaccine(patient, vaccine);</p>

<p>도메인 모델링 - 소프트웨어는 계속 진화한다. 모델 설계를 관리하지 말고 언제나 버릴 수 있어야 한다. 결국 코드가 설계 이다.</p>

<p>유비쿼터스 언어 용어집 만들기</p>

<p>도메인 정제 (결국 많은 이야기를 해야한다)</p>

<p>p.75 샘플로 도메인적 표현을 가지는 모델링을 생각해보자</p>

<p>가독성이 좋아졌다.</p>

<p>도메인의 표현이 보인다.</p>

<p>그리고 클라이언트 입장에서 테스트</p>

<p>DDD를 사용하는 데서 오는 비즈니스 가치</p>

<p>부제 : 여러분의 상사에게 DDD를 파는 방법</p>

<p>조직이 그 도메인에 유용한 모델을 얻는다.</p>

<p>정교하게 정확하게 비즈니스를 정의하고 이해한다.</p>

<p>도메인 전문가가 소프트웨어에 설계에 기여한다.</p>

<p>사용자 경험이 개선된다.</p>

<p>순수한 모델 주변에 명확한 경계가 생긴다.</p>

<p>엔터프라이즈 아키텍처의 구성이 좋아진다.</p>

<p>애자일하고, 반복적이고 지속적인 모델링이 사용된다.</p>

<p>전략적인 동시에 전술적인 새로운 도구가 적용된다.</p>

<p>DDD 적용의 난관</p>

<p>유비쿼터스 언어 만들기</p>

<p>도메인 전문가와 소통</p>

<p>개발자의 사고방식 전환 : 기술 보다는 도메인이 먼저다.</p>

<p>객체는 속성(데이터)이 중요한 것이 아니라 행동이 중요하다.</p>

<p>가장 중요한 것은 팀 내 문화와 DDD의 학습곡선 인 것 같다.</p>

<p>p.83을 보면 도메인 전문가와 친해지는 법이 나오는 게 진정 이런게 TIP 이다.</p>

<p>Example 백로그를 스프린트로 커밋한다.</p>

<p>Anemic Domain Model</p>

<p>backlogItem . setSprintId ( sprintId );</p>

<p>backlogItem . setStatus ( BacklogItemStatusType . COMMITED );</p>

<p>행위가 원자적이지 않으며, 데이터 의존적이며, 불변식이 깨질 수도 있다.</p>

<p>Rich Domain Model</p>

<p>backlogItem . commitTo ( sprint );</p>

<p>도메인의 표현이 드러나고 원자적이며, 행동이 캡슐화 되어 있으며, 도메인 모델 밖으로 로직이 세어 나가지 않는다.</p>

<p>위 상태에서 아래와 같은 추가사항이 생길 시 어떤 방식이 더 기민하게 반응할 수 있을까?</p>

<p>만약 백로그 항목이 이미 다른 스프린트로 커밋됐다면, 먼저 언커밋 해야한다. 커밋이 완료되면 이해 당사자에 알려라(도메인 이벤트)</p>

<p>도메인 모델의 합리화</p>

<p>어짜피 대부분의 엔터프라이즈 웹애플리케이션에서는 도메인 모델이 좋은 선택이라고 본다.</p>

<p>DDD는 무겁지 않다.</p>

<p>with TDD. 클라이언트 입장에서 도메인 모델을 구현하는 것은 큰 도움이 된다.</p>

<p>가상 + 약간의 현실</p>

<p>협업툴!!</p>

<p>가상의 프로로젝트를 진행하는 것으로 이야기를 풀어보자</p>

<p>사스오베이션, 그들의 제품과 DDD의 사용</p>

<p>콜랍오베이션 : SNS</p>

<p>프로젝트오베이션 : ITS</p>

<p>DDD-Lite(전술)를 이용함. 즉 바운디드 컨텍스트(전략)는 무시함.</p>

<p>마무리</p>

<p>복잡성 극복</p>

<p>트랜잭션 스크립트의 단점</p>

<p>Rich Domain Model 이 좋다.</p>

<p>DDD 약팔이</p>

<p>IDDD 1장. DDD를 시작하며 was originally published by MJ at DevOOOOOOOOP on April 27, 2018.</p>

<p>source : http://redutan.github.io/2018/04/27/IDDD-chapter01</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>IDDD 2장. 도메인, 서브도메인, 바운디드 컨텍스트</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/05/000804.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.804</id>

    <published>2018-05-10T10:07:24Z</published>
    <updated>2018-05-10T10:07:24Z</updated>

    <summary>서브도메인과 바운디드 컨텍스트로 전략적으로 설계해보자. 큰그림 서브도메인과 바운디드 컨텍스트의 활용 온라인 쇼핑몰 도메인 전자상거래 시스템 : 상품 카탈로그, 주문 , 송장, 배송 서브도메인 재고관리 시스템 : 재고관리 외부 예측 시스템 : ? 제품 카탈로그, 주문, 송장, 배송 모델 등을 하나로...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>서브도메인과 바운디드 컨텍스트로 전략적으로 설계해보자.</p>

<p>큰그림</p>

<p>서브도메인과 바운디드 컨텍스트의 활용</p>

<p>온라인 쇼핑몰 도메인</p>

<p>전자상거래 시스템 : 상품 카탈로그, 주문 , 송장, 배송 서브도메인</p>

<p>재고관리 시스템 : 재고관리</p>

<p>외부 예측 시스템 : ?</p>

<p>제품 카탈로그, 주문, 송장, 배송 모델 등을 하나로 엮어서 복잡도가 높아지며 부정적인 결과를 초래</p>

<p>소프트웨어의 관심사를 도메인을 바탕으로 분명하게 분리시켜야 한다.</p>

<p>상호 의존성을 갖기 때문에, 서브도메인으로 나누지 않는다면 변화가 계속됨에 따라 훨씬 큰 부담 을 지게 된다.</p>

<p>일반적으로 하나의 바운디드 컨텍스트에 하나의 서브도메인이 있는 것이 좋다. : 재고관리는 좋아 보인다.</p>

<p>물론 DSL이 포함되어야 한다.</p>

<p>같은 언어일지라도 개념은 전혀 다를 수 있다.</p>

<p>핵심 도메인에 집중하기</p>

<p>핵심도메인 : 주문</p>

<p>지원 서브도메인 : 배송, 상품, 송장</p>

<p>범용 서브도메인 : 회원(인증과 권한)</p>

<p>결국 도메인 전문가와 소통으로 정제하는 것이 중요하다.</p>

<p>왜 전략적 설계가 엄청나게 필수적인가</p>

<p>협업 개념이 사용자 및 권한과 강한 결합을 가지는 것이 옳은가?</p>

<p>협업 개념에서는 회원은 그저 작성자 일 뿐이다.</p>

<p>그림 2.3 팀이 전략적 설계의 기초를 이해하지 못했고, 이는 공동 모델에서 개념들이 잘못 찢어지도록 했다. 점선 안의 문제가 되는 요소들이다.</p>

<p>협업 도구는 사용자의 역할에 집중해야지, 사용자가 누구며 수행권한이 부여된 행동이 무엇인지에 관심이 있어선 안 된다. 하지만 위에서는 뒤섞여 버렸다.</p>

<p>포럼 은 단지 토론을 게시하고 싶은 작성자 만 있으면 된다.</p>

<p>사용자와 권한은 협업 컨텍스트에서 독립돼야 한다.</p>

<p>Big ball of mud : 거대한 진흙공 - 빈약한 도메인으로 가득찬 모노리식 애플리케이션</p>

<p>이런 사용자와 권한 서브도메엔을 범용 서브도메인이라고 한다.</p>

<p>이윽고 팀이 비협업 개념의 또 다른 집합을 모델링하는 상황이 오면, 핵심 도메인은 더욱 불확실해진다.</p>

<p>풍부한 협업의 유비쿼터스 언어를 제대로 소스 코드에 반영하지 못한 채, 이를 은영준에 내포하고 있을 뿐인 모델을 만들고 말 수도 있다.</p>

<p>팀은 비즈니스 도메인과 그에 따른 서브데메인은 물론이고, 반드시 그들이 개발하고 있는 바운디드 컨텍스트도 제대로 이해해야한다.</p>

<p>이를 통해 전략적 설계를 가로 막는 비열한 적인 거대한 진흙공의 더러운 물을 막을 수 있다.</p>

<p>현실의 도메인과 서브도메인</p>

<p>문제점 공간과 해결책 공간</p>

<p>도메인은 문제점 공간(problem space)과 해결책 공간(solution space)을 모두 갖고 있다.</p>

<p>문제점 공간 : 새로운 핵심 도메인을 만들기 위한 전체 도메인의 일부 > 핵심 도메인과 서브 도메인의 조합</p>

<p>해결책 공간 : 해결책을 소프트웨어로 구현 > 바운디드 컨텍스트</p>

<p>서브 도메인을 1:1로 바운디드 컨텍스트로 묶는 것은 좋은 목표이다 하지만 항상 그렇지는 않다.</p>

<p>그림 2.4 구매나 재고관리와 관련된 핵심 도메인과 다른 서브도메인. 이 관점은 특정 문제점 공간 분석을 위해 선택된 서브도메인으로 제한되며 전체 도메인에 적용할 수는 없다.</p>

<p>최적 매입 컨텍스트 = 핵심 도메인</p>

<p>구매 컨텍스트 + ERP 구매 모듈 = 구매 지원 서브 도메인</p>

<p>재고 관리 컨텍스트 + ERP 재고 모듈 = 재고 관리 지원 서브 도메인</p>

<p>매핑 컨텍스트 : 범용 서브 도메인</p>

<p>최적 매입 컨텍스트를 개발하는 회사 입장에서의 이런 핵심 포인트 를 살펴봤음을 기억하자.</p>

<p>지리적 매핑 서비스는 문제점 공간에서 재고관리 서브도메인의 일부로 간주하지만, 해결책 공간에서 재고관리 컨텍스트가 아니다.</p>

<p>매핑 서비스가 해결책 공간에선 간단한 컴포넌트 기반 API로 제공됐다 하더라도, 이는 다른 바운디드 컨텍스트다.</p>

<p>재고 관리와 매핑의 유비쿼터스 언어는 상호 배타적이며, 이는 두 요소가 서로 다른 바운디드 컨텍스트라는 의미다.</p>

<p>재고 관리 컨텍스트가 외부 매핑 컨텍스트의 어떤 부분을 사용하는 상황에서, 데이터는 적어도 최소한의 변환 을 거쳐야만 적절히 사용될 수 있다.</p>

<p>한편 구독자를 위해 매핑 서비스를 개발 하고 제공하는 외부 비즈니스 조직의 관점에서 보면 매핑은 핵심 도메인 이다.</p>

<p>전략적 이니셔티브 : KPI를 달성하기 위한 핵심적인 활동이나 계획</p>

<p>바운디드 컨텍스트 이해하기</p>

<p>바운디드 컨텍스트는 그 안에 도메인 모델이 존재하는 명시적 경계</p>

<p>바운디드 컨텍스는 명시적이고 언어적이다</p>

<p>컨텍스트가 왕이다. in DDD</p>

<p>모델의 중앙화, 범용화는 Evil 이다. 컨텍스트 별로 모델은 다른 의미를 가진다.</p>

<p>그림 2.5 두 바인디드 컨텍스트 속 어카운트 객체는 의미가 서로 완전 다르지만, 각 바운디드 컨텍스트 안에서 고려해야만 그 사실을 알 수 있다.</p>

<p>컨텍스트</p>

<p>어카운트 의미</p>

<p>예</p>

<p>은행</p>

<p>계좌</p>

<p>적금 계좌</p>

<p>문학</p>

<p>이야기</p>

<p>A Personal Account of Mt. Everest Disaster</p>

<p>모든 것을 빠짐없이 포괄하는 모델을 생성하려 시도하는 함정에 빠지며, 어디서든 통용되는 유일한 의미를 가진 이름의 개념에 대해 전체 조직이 모두 동의하는 결과를 목표로 삼는다.</p>

<p>이런 모델링 접근법에는 구멍이 있다.</p>

<p>모든 이해관계자로부터 모든 개념이 하나의 순수하고 구분된 글로벌한 의미를 갖는 것에 대해 동의를 얻기란 거의 불가능하다.</p>

<p>모든 사람을 함께 모으는 것은 절대 불가능하다. : 이건 좀 아닌 것 같음.</p>

<p>최상의 선택을 위해선 언제나 차이점은 존재한다는 사실을 직시하고 ,바운디드 컨텍스트를 통해 차이점이 명확하며 잘 이해하고 있는 도메인 모델을 각각 기술해야 한다.</p>

<p>1 바운디드 컨텍스트 != 1 프로젝트 아티팩트(산출물)</p>

<p>주문은 카탈로그 컨텍스트와 주문 컨텍스트에서 다른 모델로 표현된다.</p>

<p>고객은 등록, 계정, 배송 컨텍스트 별로 다른 모델로 표현된다.</p>

<p>모델 그 이상을 위해</p>

<p>아래 항목들도 바운디드 컨텍스트 경계 안에 있다.</p>

<p>Application Service : 보안 트랜젝션 관리 : 퍼사드</p>

<p>UI</p>

<p>Api Client : API 통합</p>

<p>안티패턴</p>

<p>Smart UI</p>

<p>바운디드 컨텍스트의 크기</p>

<p>= 유비쿼터스 언어를 표현하기 위해 필요한 크기</p>

<p>딱 내가 원했던 만큼의 음표들이 있었습니다. 더도 덜도 아닌</p>

<p>모짜르트</p>

<p>잘못된 크기의 바운디드 컨텍스트를 만들게 되는 이유?</p>

<p>아키텍처적 영향을 기준으로 삼는 경우(플랫폼, 프레임워크, 컴포넌트, 인프라 등)</p>

<p>개발자 리소스(또는 팀)를 작업을 분배하기 위해</p>

<p>기술적 컴포넌트로 정렬하기</p>

<p>com.mycompany.optimalpuchasing : bounded context</p>

<p>com.mycompany.optimalpuchasing.prsentation : ui</p>

<p>com.mycompany.optimalpuchasing.application : application</p>

<p>com.mycompany.optimalpuchasing.domain.model : domain</p>

<p>com.mycompany.optimalpuchasing.infrastructure : infra</p>

<p>샘플 컨텍스트</p>

<p>그림 2.7 완전히 서브도메인과 정렬된 바운디드 컨텍스트 샘플의 평가 관점</p>

<p>출처 : https://www.safaribooksonline.com/library/view/implementing-domain-driven-design/9780133039900/ch02lev1sec5.html</p>

<p>협업 컨텍스트</p>

<p>before</p>

<p>public class Forum extends Entity {</p>

<p>public Discussion startDiscussion (...) {</p>

<p>// repository 의존</p>

<p>User user = userRepository . userFor ( this . tenantId (), aUsername );</p>

<p>// 보안 로직</p>

<p>if (! user . hasPermissionTo ( Permission . Foru . StartDiscussion ))</p>

<p>//...</p>

<p>// 열차 충돌</p>

<p>String authorName = user . person (). name (). asFormattedName ();</p>

<p>//...</p>

<p>return newDiscussion ;</p>

<p>}</p>

<p>}</p>

<p>협업 보다는 보안을 염두함 in 협업 컨텍스트</p>

<p>전술적 패턴(DDD-Lite)으로는 해결 불가능. 전략적 설계 컨텍스트 맵!!</p>

<p>열차사고</p>

<p>usr.person().name().asFormattedName()</p>

<p>디미터의 법칙 위배</p>

<p>결론적 해결책을 통해 추가적인 전략적 설계를 사용해, 재사용 가능한 모델을 별도의 바운디드 컨텍스트로 분리하고 적절히 통합할 수 있게 됐다</p>

<p>after</p>

<p>public class ForumService {</p>

<p>@Transactional</p>

<p>public Discussion startDiscussion (...) {</p>

<p>Author author = this . colloboratorSrvice . authorFrom ( tenant , anAuthorId );</p>

<p>Discussion new Discussion = forum . startDiscussionFor (...);</p>

<p>//...</p>

<p>return newDiscussion ;</p>

<p>}</p>

<p>}</p>

<p>public class Forum extends Entity {</p>

<p>public Discussion startDiscussionFor (...) {</p>

<p>//...</p>

<p>}</p>

<p>}</p>

<p>User 와 Permission 의 의존을 제거하고 모델을 엄격히 협업에만 집중하게 함 Author</p>

<p>식별자와 엑세스 컨텍스트</p>

<p>사일로 효과 : 연통 배관 : 상호 협력을 하지 않고 중복이 생기고 각각 따로 놀게됨</p>

<p>위에서 지적된 것 처럼 식별자 컨텍스트를 분리하고 범용 지원 도메인으로써 활용</p>

<p>애자일 프로젝트 관리 컨텍스트</p>

<p>DDD 전략적 설계를 바탕으로 애자일 프로젝트 컨텍스트를 분리</p>

<p>컨텍스트는 각 팀에게 아주 구체적인 의미를 부여한다.</p>

<p>마무리</p>

<p>도메인, 서브도메인, 바운디드 컨텍스트</p>

<p>문제점 공간, 해결책 공간</p>

<p>모델을 구분(User vs Author)</p>

<p>바운디드 컨텍스트의 크기</p>

<p>사스오베이션 팀의 바운디드 컨텍스트 정제</p>

<p>IDDD 2장. 도메인, 서브도메인, 바운디드 컨텍스트 was originally published by MJ at DevOOOOOOOOP on April 28, 2018.</p>

<p>source : http://redutan.github.io/2018/04/28/IDDD-chapter02</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>상속의 위험성</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/04/000765.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.765</id>

    <published>2018-04-22T15:51:18Z</published>
    <updated>2018-04-22T15:51:18Z</updated>

    <summary>ToC 동기 사전지식 LSP Practice Summary 동기 어느 날이었습니다. 팀 내에서 상속에 대한 이야기를 하다가 주니어가 그럼 상속은 어떻게 써야하는지 궁금해 했습니다. 그런데 이 상속의 위험성을 설명하려고 하니, 말로만 하기에는 부족한 것 같고, 그렇다면 worst-case 코드를 보여줘야 하는데 시간이 없었습니다....</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>ToC</p>

<p>동기</p>

<p>사전지식</p>

<p>LSP</p>

<p>Practice</p>

<p>Summary</p>

<p>동기</p>

<p>어느 날이었습니다. 팀 내에서 상속에 대한 이야기를 하다가 주니어가 그럼 상속은 어떻게 써야하는지 궁금해 했습니다.</p>

<p>그런데 이 상속의 위험성을 설명하려고 하니, 말로만 하기에는 부족한 것 같고, 그렇다면 worst-case 코드를 보여줘야 하는데 시간이 없었습니다.</p>

<p>그래서 상속의 위험성에 대한 소스코드와 그것을 설명하는 블로그 아티클을 작성해야겠다는 생각이 들었습니다.</p>

<p>사전지식</p>

<p>Java 언어를 기본으로 설명합니다.</p>

<p>가변과 불변</p>

<p>객체지향은 가변(mutable)을 캡슐화(또는 관리)해서 복잡성을 제어합니다.</p>

<p>하지만 근본적으로 가변은 부수효과(side-effect)를 동반합니다.</p>

<p>그래서 가능하면 가변을 최소화 하는 것이 유리합니다.</p>

<p>이를 해결하기 위해서 불변(immutable)을 이용하는 것도 좋은 방법입니다.</p>

<p>접근제어자</p>

<p>public : 모두 접근 가능</p>

<p>protected : 자식 클래스와 같은 패키지 상에서 접근 가능</p>

<p>default(package) : 같은 패키지 상에서 접근 가능</p>

<p>private : 클래스 내에서만 접근 가능</p>

<p>public , protected 는 열려 있으며, default , private 는 닫혀 있다. - Joshua bloch</p>

<p>접근제어는 가능한 닫혀 있는 것이 좋습니다.</p>

<p>public field는 캡슐화되지 않으므로 Evil 으로 규정합니다.</p>

<p>불변식(불변조건)</p>

<p>클래스 불변식(Class Invariant)은 해당 클래스의 오브젝트가 가지는 제약사항을 말합니다.</p>

<p>즉 불변식이 깨지면 해당 객체는 유효하지 않다고 봐야하며 , 애플리케이션 내 클래스의 계약을 위배했으므로, 문제를 발생시킵니다.</p>

<p>예를 들어서 분수를 나타내는 클래스가 있다고 가정해 보겠습니다.</p>

<p>class 분수 {</p>

<p>public int 분자 ;</p>

<p>public int 분모 ;</p>

<p>@Override</p>

<p>public String toString () {</p>

<p>return 분자 + "/" + 분모 ;</p>

<p>}</p>

<p>}</p>

<p>class 분수 Test {</p>

<p>@Test</p>

<p>public void test 분수 _invalid () {</p>

<p>분수 분수객체 = new 분수 ();</p>

<p>분수객체 . 분자 = 1 ;</p>

<p>분수객체 . 분모 = 0 ; // !!! 분모는 0이 아니여야함 (불변식이 깨짐)</p>

<p>}</p>

<p>}</p>

<p>내부 필드가 public이기 때문에 캡슐화를 통해서 불변식을 강제할 수가 없습니다.</p>

<p>불변식 제약사항을 강제하는 메소드를 재정의함으로써도 깨질 수도 있습니다.</p>

<p>LSP</p>

<p>서브타입(sub-type)은 그것의 기반 타입(base-type)으로 치환 가능해야 한다.</p>

<p>그냥 단순하게 기반 타입으로 치환만 된다는 것을 의미하지는 않습니다. 기반 타입의 행위들을 서브 타입의 행위들로 대치해도 문제가 없고, 불변식도 깨지지 않아야 함을 의미합니다.</p>

<p>LSP를 자체를 설명하기 보다는 LSP가 위배되는 상황을 통해서 역으로 LSP를 알아보겠습니다.</p>

<p>유명한 Rectangle(직사각형) - Square(정사각형) 예제를 통해서 이를 확인해 보겠습니다.</p>

<p>class Rectangle {</p>

<p>private int width ;</p>

<p>private int height ;</p>

<p>public void setWidth ( int width ) {</p>

<p>this . width = width ;</p>

<p>}</p>

<p>public void setHeight ( int height ) {</p>

<p>this . height = height ;</p>

<p>}</p>

<p>public final int getArea () {</p>

<p>return width * height ;</p>

<p>}</p>

<p>}</p>

<p>class Square extends Rectangle {</p>

<p>@Override</p>

<p>public void setWidth ( int width ) {</p>

<p>super . setWidth ( width );</p>

<p>super . setHeight ( height );</p>

<p>}</p>

<p>@Override</p>

<p>public void setHeight ( int height ) {</p>

<p>this . setWidth ( height );</p>

<p>}</p>

<p>}</p>

<p>위 정도면 충분히 LSP 를 만족한다고 보입니다. 과연 그럴까요?</p>

<p>먼저 Square 클래스의 불변식을 알아봅시다. 정사각형이기 때문에 길이와 높이가 같은 것이 불변식입니다.</p>

<p>Rectangle 는 어떤 불변식을 가질까요? 길이와 높이가 무조건 같이 변경되면 직사각형의 불변식이 위배됩니다. - 두 타입 간 충돌이 발생하는 느낌도 있습니다.</p>

<p>즉, Square 는 길이와 높이를 무조건 같이 변경하게 되지만, Rectangle 는 길이와 높이가 같이 변경되면 예상치 못한 부수효과로 인해 불변식이 깨지게 됩니다.</p>

<p>Rectangle 의 불변식이 깨지게 됨은 상위 타입으로 치환이 불가능하다로 연결되므로 LSP도 위배하게 됩니다.</p>

<p>물론 불변식이 깨진다고 해서 무조건 LSP가 위배되는 것은 아닙니다.</p>

<p>Solution</p>

<p>먼저 상속을 유지한 상태에서 해결 방안을 알아보겠습니다.</p>

<p>class Retangle {</p>

<p>private final int width ;</p>

<p>private final int height ;</p>

<p>public Rectangle ( int width , int height ) {</p>

<p>this . width = width ;</p>

<p>this . height = height ;</p>

<p>}</p>

<p>public final int getArea () {</p>

<p>return width * height ;</p>

<p>}</p>

<p>}</p>

<p>class Square extends Rectangle {</p>

<p>public Square ( int length ) {</p>

<p>super ( length , length );</p>

<p>}</p>

<p>}</p>

<p>부수효과는 가변메서드(Setter)에서 발생합니다. 그럼 애초에 원인이 되는 가변을 모두 제거해서 위와 같이 불변(Immutable)을 통해서 문제를 해결 할 수 있습니다.</p>

<p>Another Solution</p>

<p>다른 방법을 알아볼까요?</p>

<p>애초에 이 애플리케이션 세계에서 사각형과 정사각형은 상속구조가 어울리지 않는 것 같습니다.</p>

<p>interface Shape {</p>

<p>int getArea ();</p>

<p>}</p>

<p>final class Rectangle implements Shape {</p>

<p>private final int width ;</p>

<p>private final int height ;</p>

<p>public Rectangle ( int width , int height ) {</p>

<p>this . width = width ;</p>

<p>this . height = height ;</p>

<p>}</p>

<p>@Override</p>

<p>public int getArea () {</p>

<p>return width * height ;</p>

<p>}</p>

<p>}</p>

<p>final class Square implements Shape {</p>

<p>private Rectangle target ;</p>

<p>public Square ( int length ) {</p>

<p>setLength ();</p>

<p>}</p>

<p>public void setLength ( int length ) {</p>

<p>this . target = new Rectangle ( length , length );</p>

<p>}</p>

<p>@Override</p>

<p>public int getArea () {</p>

<p>return target . getArea ();</p>

<p>}</p>

<p>}</p>

<p>상속 보다는 합성(Composition) 원칙에 입각해서 위와 같이 수정하는 것도 한 방법입니다.</p>

<p>실제로 중요한 것은 넓이를 구하는 행위이지 사각형이냐, 정사각형이냐는 그 다음 문제입니다.</p>

<p>또한 합성을 이용하면 Setter(‘setLength’)가 있더라도 불변식이 깨지는 부수효과가 발생하지 않습니다.</p>

<p>Practice</p>

<p>아래 다양한 예시를 통해서 더 안전한 상속을 구현하는 방법을 알아보겠습니다.</p>

<p>메서드 재정의</p>

<p>메서드가 재정의 불가능하게 final 로 닫는 것이 좋습니다.</p>

<p>Bad</p>

<p>base : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/override/BadSuperObject.java</p>

<p>Good</p>

<p>https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/override/GoodSuperObject.java</p>

<p>Support 타입</p>

<p>상속을 단순 코드 재사용으로 사용하는 경우(추상 메서드가 없는 경우)에는 합성(Composition)을 사용하는 것이 좋습니다.</p>

<p>Bad</p>

<p>base : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/support/ProcessSupport.java</p>

<p>sub : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/support/BadMainProcess.java</p>

<p>Good</p>

<p>helper : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/support/ProcessHelper.java</p>

<p>client : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/support/GoodMainProcess.java</p>

<p>Template</p>

<p>템플릿 메소드 패턴의 경우 아래와 같은 코드로 정형화 하는 것이 좋습니다. - 이것은 상속을 이용한 Good Practice 중 하나입니다.</p>

<p>템플릿 패턴은 변하는 부분과 변하지 않는 부분의 관심사 분리가 중요합니다.</p>

<p>변하는 부분은 다형성을 위해 열어두고 변하지 않는 부분은 불변 템플릿(final)으로 만듭니다.</p>

<p>Good Sample 중 일부 코드</p>

<p>public abstract class AbstractSafePrefixContentHolder implements ContentHolder {</p>

<p>// 가능한 필드는 닫고 불변화 시킨다. 접근이 필요할 때만 점진적으로 연다.</p>

<p>private final String content ;</p>

<p>public AbstractSafePrefixContentHolder ( String content ) {</p>

<p>this . content = Objects . requireNonNull ( content ); // 여기에서 제약조건을 추가할 수 있다. : 선행조건으로 불변식 강제</p>

<p>}</p>

<p>@Override // 템플릿 : 재정의 불가능하게 final</p>

<p>public final String getContent () {</p>

<p>return getPrefix () + content ;</p>

<p>}</p>

<p>// 다형성으로써 추상 메서드만 오픈시킨다.</p>

<p>abstract protected String getPrefix ();</p>

<p>}</p>

<p>Bad</p>

<p>base : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/template/AbstractPrefixContentHolder.java</p>

<p>sub : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/template/BadContentHolder.java</p>

<p>Good</p>

<p>base : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/template/AbstractSafePrefixContentHolder.java</p>

<p>sub : https://github.com/redutan/dangers-of-inheritance/blob/master/src/main/java/io/redutan/dangers/inheritance/template/GoodContentHolder.java</p>

<p>Summary</p>

<p>불변식을 지킵니다.</p>

<p>접근제어는 가능한 닫습니다 : field는 private 로</p>

<p>가능한 변경을 최소화 합니다 : final</p>

<p>불변을 이용하거나, 인터페이스를 통한 합성으로 변경해 봅니다.</p>

<p>예외</p>

<p>하지만 모든 경우에서 위 원칙을 지키는 것은 힘들수도 있습니다.</p>

<p>상속의 위험성을 모두 파악한 상태에서 문서(javadoc)를 통해서 제약사항을 명시해서 언어로써 강제하는 것이 아니라 프로그래머가 스스로 제약사항을 지키게 하는 것도 한 방법입니다.</p>

<p>http://redutan.github.io/2016/02/26/effective-java2-chapter04#rule-17—계승을-위한-설계와-문서를-갖추거나-그럴-수-없다면-계승을-금지하라</p>

<p>그리고 특정 도메인(ex:환경설정)에서는 위 상속의 위험성을 무시할 수도 있습니다.</p>

<p>Reference</p>

<p>github : https://github.com/redutan/dangers-of-inheritance/</p>

<p>http://redutan.github.io/2016/02/26/effective-java2-chapter04</p>

<p>http://redutan.github.io/2017/06/10/clean-software-part02-2</p>

<p>https://en.wikipedia.org/wiki/Class_invariant</p>

<p>https://ko.wikipedia.org/wiki/리스코프_치환_원칙</p>

<p>상속의 위험성 was originally published by MJ at DevOOOOOOOOP on April 21, 2018.</p>

<p>source : http://redutan.github.io/2018/04/21/dangers-of-inheritance</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

<entry>
    <title>IntelliJ SonarLint Plugin</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/04/000743.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.743</id>

    <published>2018-04-11T07:10:29Z</published>
    <updated>2018-04-11T07:10:29Z</updated>

    <summary>동기 시작은 popit 아티클 어느날 popit에 sonarqube를 이용한 코드 자동리뷰 아티클이 올라왔습니다. http://www.popit.kr/내코드를-자동으로-리뷰해준다면-by-sonarqube/ 조직장(요다 )이 이것을 팀 내에 적용해보자고 해서 (이미 저희 팀은 sonarqube로 정적분석을 하고 있습니다.) 적용을 시작합니다. 생각보다 적용이 쉽지 않으며, 설정 포인트도 많습니다. 물론 한 번 힘들게...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[동기

시작은 popit 아티클

어느날 popit에 sonarqube를 이용한 코드 자동리뷰 아티클이 올라왔습니다.

http://www.popit.kr/내코드를-자동으로-리뷰해준다면-by-sonarqube/

조직장(요다 )이 이것을 팀 내에 적용해보자고 해서 (이미 저희 팀은 sonarqube로 정적분석을 하고 있습니다.) 적용을 시작합니다.

생각보다 적용이 쉽지 않으며, 설정 포인트도 많습니다. 물론 한 번 힘들게 설정하면 그 이후에는 자동화되기 때문에 tradeoff 할 만 하지요. 적용할 프로젝트 수 자체가 많으면 초기 설정이 조금 힘들 순 있습니다. - 하지만 단순 반복 작업이기 때문에 복사하기-붙여넣기 를 잘하면 되긴 합니다. -

하지만 코드를 작성하고, 커밋하고, 푸시하고, PullRequest를 올려야지 정적분석 피드백을 받을 수 있습니다. 즉, 코드 작성 시와 정적분석 피드백 시 사이의 시간 차가 너무 큽니다.

그래서 코드를 작성과 가능한 가까운 시간에 바로 피드백 을 받는 것이 더 좋지 않을까 하는 생각이 들었습니다.

대안 : SonarLint

그러던 중 팀원 콤틴 이 IDEA plugin인 SonarLint 를 사용하는 것을 추천하였습니다.

팀 내에서 IntelliJ IDEA를 사용하고 있었고, 확실히 합리적인 선택이 될 것 같았습니다.

SonarLint 적용

Install

preference > plugins

SonarLint 검색

결과창 내 Search in repositories 링크 선택 or 하딘 Browse repositories... 버튼 선택

Install and Restart IntelliJ IDEA

Staring과 다운로드 갯수가 많고, 최근 업데이트도 지속되고 있는 것 같아서 믿을만한 플러그인 같습니다

Install 확인

Configuration

기본적인 설정만으로도 충분히 사용할 수 있으며 sonarqube 서버가 없어도 사용에 문제가 없습니다.

SonarQube 서버 연동

서버 연동을 하게 되면 더 다양한 분석룰을 팀 내 전반적으로 일관성 있게 관리할 수 있습니다.

preference > Other Settings > SoanrLint General Settings

Automatically trigger analysis 체크하는 것을 추천

또는 해제하고 commit 시에만 분석하는것도 좋음

위 화면을 통해서 적절하게 설정하면 됨

SoanrLint Project Settings 를 통한 설정도 가능

Commit 시 분석 추가

커밋(Cmd + K ) 창에서

Perform SonarLint analysis 를 선택 (기본으로 체크되어 있음)

개인적으로 추천 commit 할 때마다 분석이 됨

Usage

현재 파일 분석

mac : Cmd + Opt + S

or

그 외 가능한 사용법

전체 파일 분석 : Analyze All Files with SonarLint

VCS(ex: git)상 변경된 분석 검사 : Analyze VCS Changed Files with SonarLint

*Cmd + Opt + A , SonarLint 로 검색한 액션들

Analyze Example

public class AccountRestController {

...

@PostMapping

public ResponseEntity 

IntelliJ SonarLint Plugin was originally published by MJ at DevOOOOOOOOP on April 11, 2018.

source : http://redutan.github.io/2018/04/11/intellij-sonarlint-plugin<br />---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW
]]>
        
    </content>
</entry>

<entry>
    <title>클린소프트웨어 Part 6. ETS 사례 연구</title>
    <link rel="alternate" type="text/html" href="http://weblog.youre.space/redutan/2018/02/000544.html" />
    <id>tag:weblog.youre.space,2018:/redutan//17.544</id>

    <published>2018-02-26T05:53:27Z</published>
    <updated>2018-02-26T05:53:27Z</updated>

    <summary>비지터 패턴 클래스 계층 구조에 새로운 메소드를 추가할 필요가 있지만, 그렇게 하는 작업은 고통스럽거나 설계를 해치게 된다. 디자인 패턴의 비지터 집합 타입 계층 구조를 변경하지 않고도 새로운 메소드를 계층 구조에 추가할 수 있음 비지터(Visitor) 비순환 비지터(Acyclic Visitor) 데코레이터(Decorator) 비지터 패턴...</summary>
    <author>
        <name>Sangyong Gwak</name>
        <uri>http://weblog.youre.space/vergence/</uri>
    </author>
    
    
    <content type="html" xml:lang="en-us" xml:base="http://weblog.youre.space/redutan/">
        <![CDATA[<p>비지터 패턴</p>

<p>클래스 계층 구조에 새로운 메소드를 추가할 필요가 있지만, 그렇게 하는 작업은 고통스럽거나 설계를 해치게 된다.</p>

<p>디자인 패턴의 비지터 집합</p>

<p>타입 계층 구조를 변경하지 않고도 새로운 메소드를 계층 구조에 추가할 수 있음</p>

<p>비지터(Visitor)</p>

<p>비순환 비지터(Acyclic Visitor)</p>

<p>데코레이터(Decorator)</p>

<p>비지터 패턴 상세</p>

<p>이중 디스패치(dual dispatch) : 실행되는 연산이 요청의 종류와 두 수신자의 타입에 따라 달라진다는 뜻</p>

<p>비지터 패턴 클래스 다이어그램</p>

<p>비지터 패턴 시퀀스 다이어그램</p>

<p>연산의 변화 vs 구조의 변화</p>

<p>새로운 구상체가 계속 추가된다면 Visitor은 독이 된다.</p>

<p>새로운 연산이 계속 추가된다면 Vistor은 좋은 선택이다.</p>

<p>비순환 비지터 패턴</p>

<p>down-casting가 있어서 쓰기가 꺼려진다.</p>

<p>타입안정성이 약해짐</p>

<p>만약 generic 을 이용할 수 있다면 더 낫지 않을까?</p>

<p>public void accept ( ModemVisitor v ) {</p>

<p>try {</p>

<p>ErniedModemVisitor ev = ( ErnieModemVisitor ) v ; // !!!</p>

<p>ev . visit ( this );</p>

<p>} catch ( ClassCastException e ) {</p>

<p>}</p>

<p>}</p>

<p>p.505 ErnieModem.java 일부</p>

<p>데코레이터 패턴</p>

<p>소리나는 다이얼 모뎀을 만들고 싶다</p>

<p>OCP, SRP 원칙을 지킬려면 어떻게 해야할까?</p>

<p>데코레이터 !!!</p>

<p>public class LoudDialModem implements Modem {</p>

<p>private Model modem ;</p>

<p>public LoudDialModem ( Modem m ) {</p>

<p>this . modem = m</p>

<p>}</p>

<p>public void dial ( String pno ) {</p>

<p>modem . setSpeakerVolume ( 10 ); // 데코레이팅!!!</p>

<p>modem . dial ( pno )</p>

<p>}</p>

<p>...</p>

<p>}</p>

<p>확장 객체 패턴</p>

<p>아답터 패턴과 유사하다.</p>

<p>단점은 역시나 많은 subclass를 동반하는 것이다.</p>

<p>장점은 OCP와 SRP를 지킬 수 있다</p>

<p>확장 객체 패턴 클래스 다이어그램</p>

<p>참고 : The Extension Objects Pattern.pdf</p>

<p>스테이트 패턴</p>

<p>유한 상태 오토마타의 개괄</p>

<p>유한 상태 기계 : Finite State Machine</p>

<p>ex) 개찰구</p>

<p>개찰구 상태 다이어그램</p>

<p>구현기법 : 중첩된 switch/case</p>

<p>switch ( state ) {</p>

<p>case LOCKED :</p>

<p>switch ( event ) {</p>

<p>case COIN :</p>

<p>state = UNLOCKED ;</p>

<p>turnstileController . unlock ();</p>

<p>break ;</p>

<p>case PASS :</p>

<p>turnstileController . alarm ();</p>

<p>break ;</p>

<p>}</p>

<p>break ;</p>

<p>case UNLOCKED :</p>

<p>switch ( event ) {</p>

<p>case COIN :</p>

<p>turnstileController . thankyou ();</p>

<p>break ;</p>

<p>case PASS :</p>

<p>state = LOCKED ;</p>

<p>turnstileController . lock ();</p>

<p>break ;</p>

<p>}</p>

<p>break ;</p>

<p>}</p>

<p>turnstile : 개찰구</p>

<p>접근제어가 패키지인 상태변수</p>

<p>ISSUE 테스트를 진행할려면 테스트에서 상태를 변경할 수 있어야 한다.</p>

<p>이를 위해서 같은 패키지에서 만들어지는 테스트를 위해서 상태 변수를 패키지 접근제어로 변경하였다.</p>

<p>effective-java에 의하면 패키지 접근제어도 캡슐화가 깨지지 않는 것으로 보이므로 큰 문제가 없다고 판단되며, 본인도 종종 이것을 애용하는 편이다.</p>

<p>하지만 가능했다면, 패키지 생성자나 패키지 setter 메소드로 조금 더 제한하면 좋을 것 같다.</p>

<p>만약 C++이었다면 friend로 해결가능했을 것이다.</p>

<p>중첩된 switch/case의 장단점</p>

<p>간단한 상황에서는 가독성이 높고 효율적</p>

<p>복잡한 상황에서는 가독성이 떨어지고 유지보수도 어려워지며, 실수에 취약하다.</p>

<p>중복코드도 많이 생긴다.</p>

<p>구현기법 : 전이 테이블 해석</p>

<p>// 테이블 구축</p>

<p>public Trunstile ( TurnstileController action ) {</p>

<p>turnstileController = action ;</p>

<p>addTransition ( LOCKED , COIN , UNLOCKED , unlock ()); // 마지막 메서드는 람다식으로 하면 더 나을 것 같다.</p>

<p>addTransition ( LOCKED , PASS , LOCKED , alarm ());</p>

<p>addTransition ( UNLOCKED , COIN , UNLOCKED , thankyou ());</p>

<p>addTransition ( UNLOCKED , PASS , LoCKED , lock ());</p>

<p>}</p>

<p>...</p>

<p>// 전이 엔진</p>

<p>public void event ( int event ) {</p>

<p>for ( Transition transition : transitions ) {</p>

<p>// 아래 분기문은 transition의 메서드로 분기하면 좋을 것 같다. : transition.isTransferable(state, event)</p>

<p>if ( state == transition . currentState && event == transition . event ) {</p>

<p>state = transition . newState ;</p>

<p>transition . action . execute ();</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>전이 테이블 해석의 장단점</p>

<p>정규적이며, 가독성이 좋다.</p>

<p>runtime 시 테이블 교체 가능(동적 제어)</p>

<p>ISSUE 테이블의 양이 커지면 검색 시간이 오래 걸린다??</p>

<p>ISSUE 테이블을 지원하기 위한 코드의 양도 많아 진다??</p>

<p>구현기법 : 스테이트 패턴</p>

<p>ISSUE 하지만 예제에서는 Turnstile가 구상상태(TunstileLockedState 등)에 의존하고 있어서 DIP 원칙이 깨지고 있다. - p.544</p>

<p>Gof : 스테이트 패턴</p>

<p>Tcp를 예제로 한 스테이트 패턴 클래스 다이어그램</p>

<p>TCP Established : 연결상태</p>

<p>TCP Listen : 연결대기</p>

<p>TCP Closed : 종료</p>

<p>참고 : TCP 연결 상태 의미</p>

<p>스테이트와 스트래터지</p>

<p>스테이트 : 상태의 다형성 확보</p>

<p>스트래터지 : 알고리즘(행위)의 다형성 확보</p>

<p>context의 상태 변경이 일어나는가?</p>

<p>스테이트 패턴의 장단점</p>

<p>OCP, SRP를 만족할 수 있다.</p>

<p>상태 마다 각각 subclass가 필요해서 비용이 많이 든다.</p>

<p>상태 기계의 모든 논리를 한 번에 파악할 수 없다 (vs 전이 테이블)</p>

<p>상태 기계 컴파일러(SMC)</p>

<p>전이 테이블 + 스테이트 패턴 = 3차원 유한 상태 기계(THREE-LEVEL FINITE STATE MACHINE)</p>

<p>상태 기계 컴파일러 장단점</p>

<p>그냥 좋다. = Best practice</p>

<p>클린소프트웨어 Part 6. ETS 사례 연구 was originally published by MJ at DevOOOOOOOOP on October 08, 2017.</p>

<p>source : http://redutan.github.io/2017/10/08/clean-software-part06</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>
]]>
        
    </content>
</entry>

</feed>
