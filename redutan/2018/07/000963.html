<!DOCTYPE html>
<html lang="en-us" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="UTF-8">
    <meta name="description" content="전역(global) 액세스가 필요한 각 객체의 타입이다, 해당 타입의 모든 객체가 담긴 인메모리 컬렉션이란 허상을 제공하는 객체를 생성하자. 잘 알려진 전역의 인터페이스를 통한 액세스를 설정하자. 객체를 추가하거나 제거하는 메소드를 제공하자… 일정 조건에 부합되는 특성을 갖는 객체를 선택해 완전히 인스턴스화된 객체나 여러...">
    <meta name="generator" content="Movable Type 6.3.6">
    <title>IDDD 12장. 리파지토리 - redutan</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="https://weblog.youre.space/redutan/styles.css">
    <!--[if lt IE 9]>
    <link rel="stylesheet" href="https://weblog.youre.space/redutan/styles_ie.css">
    <script src="https://connexus.youre.space/mt-static/support/theme_static/rainier/js/html5shiv.js"></script>
    <![endif]-->
    
    <link rel="start" href="https://weblog.youre.space/redutan/">
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="https://weblog.youre.space/redutan/atom.xml" />
    <link rel="canonical" href="https://weblog.youre.space/redutan/2018/07/000963.html" />
    <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-102177098-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


    <link rel="prev" href="https://weblog.youre.space/redutan/2018/06/000947.html" title="IDDD 111장. 팩토리">
    <link rel="next" href="https://weblog.youre.space/redutan/2018/07/001043.html" title="IDDD 6장. 값 객체">
    <!-- Open Graph Protocol -->
    <meta property="og:type" content="article">
    <meta property="og:locale" content="en-us">
    <meta property="og:title" content="IDDD 12장. 리파지토리">
    <meta property="og:url" content="https://weblog.youre.space/redutan/2018/07/000963.html">
    <meta property="og:description" content="전역(global) 액세스가 필요한 각 객체의 타입이다, 해당 타입의 모든 객체가 담긴 인메모리 컬렉션이란 허상을 제공하는 객체를 생성하자. 잘 알려진 전역의 인터페이스를 통한 액세스를 설정하자. 객체를 추가하거나 제거하는 메소드를 제공하자… 일정 조건에 부합되는 특성을 갖는 객체를 선택해 완전히 인스턴스화된 객체나 여러...">
    <meta property="og:site_name" content="redutan">
    <meta property="og:image" content="https://connexus.youre.space/mt-static/support/theme_static/rainier/img/siteicon-sample.png">
    <!-- Metadata -->
    <meta itemprop="description" content="전역(global) 액세스가 필요한 각 객체의 타입이다, 해당 타입의 모든 객체가 담긴 인메모리 컬렉션이란 허상을 제공하는 객체를 생성하자. 잘 알려진 전역의 인터페이스를 통한 액세스를 설정하자. 객체를 추가하거나 제거하는 메소드를 제공하자… 일정 조건에 부합되는 특성을 갖는 객체를 선택해 완전히 인스턴스화된 객체나 여러...">
    <link itemprop="url" href="https://weblog.youre.space/redutan/2018/07/000963.html">
    <link itemprop="image" href="https://connexus.youre.space/mt-static/support/theme_static/rainier/img/siteicon-sample.png">
    
  </head>
  <body>
    <div id="container">
      <div id="container-inner">
        <header id="header" role="banner">
          <div id="header-inner">
            <div id="header-content">
              <h1>
                <a href="https://weblog.youre.space/redutan/">

                  redutan

                </a>
              </h1>
              
            </div>

            <nav role="navigation">
          <ul>
            <li><a href="https://weblog.youre.space/redutan/">Home</a></li>


          </ul>
        </nav>

          </div>
        </header>
        <div id="content">
          <div id="content-inner">
            <ul class="breadcrumb breadcrumb-list">
              <li class="breadcrumb-list-item"><a href="https://weblog.youre.space/redutan/">Home</a></li>
              <li class="breadcrumb-list-item">IDDD 12장. 리파지토리</li>
            </ul>
            <div id="individual-main" class="main" role="main">
              <article id="entry-963" class="entry entry-asset asset hentry">
                <div class="asset-header">
                  <h2 itemprop="name" class="asset-name entry-title">IDDD 12장. 리파지토리</h2>
                  <footer class="asset-meta">
                    <ul class="asset-meta-list">
                      <li class="asset-meta-list-item">Posted on <time datetime="2018-07-13T07:25:27+09:00" itemprop="datePublished">July 13, 2018</time></li>
                      <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

                   </ul>
                </footer>
                </div>
                <div class="entry-content asset-content" itemprop="articleBody">
                  <p>전역(global) 액세스가 필요한 각 객체의 타입이다, 해당 타입의 모든 객체가 담긴 인메모리 컬렉션이란 허상을 제공하는 객체를 생성하자.</p>

<p>잘 알려진 전역의 인터페이스를 통한 액세스를 설정하자.</p>

<p>객체를 추가하거나 제거하는 메소드를 제공하자…</p>

<p>일정 조건에 부합되는 특성을 갖는 객체를 선택해 완전히 인스턴스화된 객체나 여러 객체의 컬렉션으로 반환하는 메소드를 제공하자…</p>

<p>애그리게잇에 대해서만 리파지토리를 제공하자.. [Evans]</p>

<p>애그리게잇 : 리파지토리 = 1(..N):1</p>

<p>컬렉션 지향 리파지토리</p>

<p>package java . util ;</p>

<p>public interface Collection {</p>

<p>public boolean add ( Object o );</p>

<p>public boolean addAll ( Collection c );</p>

<p>public boolean remove ( Object o );</p>

<p>public boolean removeAll ( Collection c );</p>

<p>}</p>

<p>같은 인스턴스를 두번 추가되도록 허용해서는 안된다.</p>

<p>재저장 을 할 필요가 없다.</p>

<p>그저 객체의 상태를 변경시키면 자동으로 저장될 뿐이다.</p>

<p>결국 Set 처럼 행동해야 한다.</p>

<p>재저장 할 필요가 없다면 객체의 상태를 추적해야한다.</p>

<p>영속성 매커니즘의 암시적 변경 추적 기법</p>

<p>암시적 읽기 시 복사(Copy-on-Read) : 읽을 때 복사본을 만들어 두고 복사본과 비교해서 변경된 것이 있으면 Commit 시킨다.</p>

<p>암시적 쓰기 시 복사(Copy-on-Write) : 프록시로 감싸두고 Dirty(상태 변경이 되면)인 경우 Commit 시킨다.</p>

<p>하이버네이트 구현</p>

<p>package com . saasovation . collaboration . domain . model . calendar ; //!!</p>

<p>interface CalendarEntryRepository {</p>

<p>void add ( CalendarEntry calendarEntry );</p>

<p>void addAll ( Collection  calendarEntries );</p>

<p>void remove ( CalendarEntry calendarEntry );</p>

<p>void removeAll ( Collection  calendarEntries );</p>

<p>CalendarEntry calendarEntryOfId ( Tenant tenant , CalendarEntriyId id );</p>

<p>Collection  calendarEntriesOfCalendar (</p>

<p>Tenant tenant , CalendarId calendarId );</p>

<p>Collection  overlappingCalendarEntries (</p>

<p>Tenant tenant , CalendarId calendarId , TimeSpan timeSpan );</p>

<p>CalendarEntryId nextIdentity ();</p>

<p>}</p>

<p>package 는 도메인 모델과 함께한다.</p>

<p>물리적 삭제 VS 논리적 삭제</p>

<p>package com . saasovation . collaboration . infrastructure . persistence ;</p>

<p>public class HibernateCalendarEntryRepository</p>

<p>implements CalendarEntryRepository {</p>

<p>private final SpringHibernateSessionProvider sessionProvider ;</p>

<p>public HibernateCalendarEntryRepository (</p>

<p>SpringHibernateSessionProvider sessionProvider ) {</p>

<p>this . sessionProvider = sessionProvider ;</p>

<p>}</p>

<p>private org . hibernate . Session session () {</p>

<p>return this . sessionProvider . session ();</p>

<p>}</p>

<p>@Override</p>

<p>public void add ( CalendarEntry calendarEntry ) {</p>

<p>this . session (). saveOrUpdate ( calendarEntry );</p>

<p>}</p>

<p>@Override</p>

<p>public void addAll ( Collection  calendarEntries ) {</p>

<p>for ( CalendarEntry each : calendarEntries ) {</p>

<p>this . session (). saveOrUpdate ( each );</p>

<p>}</p>

<p>}</p>

<p>@Override</p>

<p>public void remove ( CalendarEntry calendarEntry ) {</p>

<p>this . session (). delete ( calendarEntry );</p>

<p>}</p>

<p>@Override</p>

<p>public void removeAll ( Collection  calendarEntries ) {</p>

<p>for ( CalendarEntry each : calendarEntries ) {</p>

<p>this . session (). delete ( each );</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>package : infrastructure.persistence</p>

<p>Set 과 유사한 행위 제공</p>

<p>Cascade 를 통한 연관된 엔터티를 같이 변경하는 기능도 있음</p>

<p>복잡한 조회의 경우 HQL을 이용</p>

<p>하지만 JPA를 사용한다면 JPQL을 사용하나, 현재까지는 querydsl 과 같은 기술이 좋은 것 같다.</p>

<p>탑링크 구현에 대한 고려</p>

<p>탑링크는 명시적으로 작업단위(Unit of work) 를 지정할 수 있다.</p>

<p>일종의 트랜잭션의 범위를 추상화 시킨 것</p>

<p>Calendar calendar = session . readObject (...);</p>

<p>UnitOfWork work = session . acquireUnitOfWork ();</p>

<p>Calendar calendarToRename = work . registerObject ( calendar );</p>

<p>calendarToRename . rename ( "CollabOvation Project Calendar" );</p>

<p>work . commit ();</p>

<p>package com . saasovation . collaboration . infrastructure . persistence ;</p>

<p>public class ToplinkCalendarEntryRepository</p>

<p>implements CalendarEntryRepository {</p>

<p>@Override</p>

<p>public void add ( Calendar calendar ) {</p>

<p>this . unitOfWork (). registerNewObject ( calendar );</p>

<p>}</p>

<p>@Override</p>

<p>public void editingCopy ( Calendar calendar ) {</p>

<p>return ( Calendar ) this . unitOfWork (). registerObject ( calendar );</p>

<p>}</p>

<p>}</p>

<p>영속성 지향의 리파지토리</p>

<p>컬렉션 지향 리파지토리 : Set</p>

<p>영속성 지향 리파지토리 : HashMap</p>

<p>하지만 꼭 put 를 해야한다. - 원자적 쓰기를 통제할 수 없음(트랜잭션 없음)</p>

<p>No-Sql 종류가 많다.</p>

<p>잼파이어</p>

<p>코히어런스</p>

<p>몽고DB</p>

<p>리악</p>

<p>코히어런스 구현</p>

<p>package com . saasovation . agilepm . domain . model . product ;</p>

<p>interface ProductRepository {</p>

<p>ProductId nextIdentity ();</p>

<p>Collection  allProductsOfTenant ( Tenant tenant );</p>

<p>Product productOfId ( Tenant tenant , ProductId productId );</p>

<p>void remove ( Product product );</p>

<p>void removeAll ( Collection  products );</p>

<p>void save ( Product product );</p>

<p>void saveAll ( Collection  products );</p>

<p>}</p>

<p>package com . saasovation . agilepm . infrastructure . persistence ;</p>

<p>class CoherenceProductRepository</p>

<p>implements ProductRepository {</p>

<p>private Map  caches ;</p>

<p>public CoherenceProductRepository () {</p>

<p>this . caches = new HashMap >();</p>

<p>}</p>

<p>private synchronized NamedCache ( TenantId tenantId ) {</p>

<p>NamedCache cache = this . caches . get ( tenantId );</p>

<p>if ( cache == null ) {</p>

<p>// ageilepm:Product:TenantId</p>

<p>// 1단계 : 2단계 : 3단계</p>

<p>cache = CacheFactory . getCache (</p>

<p>"agilepm.Product." + tenantId . id (),</p>

<p>Product . class . getClassLoader ());</p>

<p>this . caches . put ( tenantId , cache );</p>

<p>}</p>

<p>return cache ;</p>

<p>}</p>

<p>@Override</p>

<p>public void save ( Product product ) {</p>

<p>this . cache ( product . tenantId ())</p>

<p>. put ( this . idOf ( product ), product );</p>

<p>}</p>

<p>@Override</p>

<p>public void saveAll ( Collection  products ) {</p>

<p>Map  productsMap =</p>

<p>new HashMap >( products . size ());</p>

<p>for ( Product each : products ) {</p>

<p>if ( tenantId == null ) {</p>

<p>tenantId = product . tenantId ();</p>

<p>}</p>

<p>productsMap . put ( this . idOf ( product ), each );</p>

<p>}</p>

<p>this . cache ( tenantId ). putAll ( productsMap );</p>

<p>}</p>

<p>private String idOf ( Product product ) {</p>

<p>return this . idOf ( product . productId ());</p>

<p>}</p>

<p>private String idOf ( ProductId productId ) {</p>

<p>return productId . id ();</p>

<p>}</p>

<p>@Override</p>

<p>public void remove ( Product product ) {</p>

<p>this . cache ( product . tenantId ()). remove ( this . idOf ( product ));</p>

<p>}</p>

<p>@Override</p>

<p>public void removeAll ( Collection  products ) {</p>

<p>for ( Product each : products ) {</p>

<p>this . remove ( product );</p>

<p>}</p>

<p>}</p>

<p>@Override</p>

<p>public Collection  allProductsOfTenant ( Tenant tenant ) {</p>

<p>Set > entries =</p>

<p>this . cache ( tenant ). entrySet ();</p>

<p>Collection  products =</p>

<p>new HashSet ( entries . size ());</p>

<p>for ( Map . Entry  entry : entries ) {</p>

<p>products . add ( entry . getValue ());</p>

<p>}</p>

<p>return products ;</p>

<p>}</p>

<p>@Override</p>

<p>public Product productOfId ( Tenant tenant , ProductId productId ) {</p>

<p>return ( Product ) this . cache ( tenant ). get ( this . idOf ( productId ));</p>

<p>}</p>

<p>}</p>

<p>몽고DB 구현</p>

<p>애그리게잇을 -> 몽고DB포맷(직렬화), 몽고DB포맷 -> 애그리게잇(역직렬화)</p>

<p>몽고DB 문서의 고유 식별자(_id )</p>

<p>몽고DB 노드/클러스터 참조</p>

<p>class MongoProductRepository</p>

<p>extends MongoRepository </p>

<p>implements ProductRepository {</p>

<p>public MongoProductRepository () {</p>

<p>super ();</p>

<p>this . serializer ( new BSONSerializer ( Product . class ));</p>

<p>}</p>

<p>public ProductId nextIdentity () {</p>

<p>// 몽고DB에서 제공하는 식별자. _id 필드에 매핑시킬수 있음</p>

<p>return new ProductId ( new ObjectId (). toString ());</p>

<p>}</p>

<p>@Override</p>

<p>public void save ( Product product ) {</p>

<p>this . databaseCollection (</p>

<p>this . collectionName ( product . tenantId ()))</p>

<p>. save ( this . serialize ( product ));</p>

<p>}</p>

<p>protected String collectionName ( TenantId tenantId ) {</p>

<p>return "product" + tenantId . id ();</p>

<p>}</p>

<p>protected String databaseName () {</p>

<p>return "agilepm" ;</p>

<p>}</p>

<p>@Override</p>

<p>public Collection  allProductsOfTenant (</p>

<p>TenantId tenantId ) {</p>

<p>Collection  products = new ArrayList >();</p>

<p>DBCursor cursor =</p>

<p>this . databaseCollection (</p>

<p>this . databaseName (),</p>

<p>this . collectionName ( tenantId )). find ();</p>

<p>while ( curosr . hasNext ()) {</p>

<p>DBObject dbObject = cursor . next ();</p>

<p>Product product = this . deserialize ( dbObject );</p>

<p>products . add ( product );</p>

<p>}</p>

<p>return products ;</p>

<p>}</p>

<p>@Override</p>

<p>public Product productOfId (</p>

<p>TenantId tenantId , ProductId productId ) {</p>

<p>Product product = null ;</p>

<p>BasicDBObject query = new BasicDBObject ();</p>

<p>query . put ( "producetId" ,</p>

<p>new BasicDBObject ( "id" , productId . id ()));</p>

<p>DBCursor cursor =</p>

<p>this . databaseCollection (</p>

<p>this . databaseName (),</p>

<p>this . collectionName ( tenantId )). find ( query );</p>

<p>if ( cursor . hasNext ()) {</p>

<p>product = this . deserialize ( cursor . next ());</p>

<p>}</p>

<p>return product ;</p>

<p>}</p>

<p>}</p>

<p>class BSONSerializer  {</p>

<p>DBObject serialize ( String key , T object ) {</p>

<p>DBObject serialization = this . serialize ( object );</p>

<p>serialization . put ( "_id" , new ObjectId ( key ));</p>

<p>return serialization ;</p>

<p>}</p>

<p>}</p>

<p>abstract class MongoRepository  {</p>

<p>protected DBCollection databaseCollection (</p>

<p>String databaseName , String collectionName ) {</p>

<p>return MongoDatabaseProvider</p>

<p>. database ( databaseName )</p>

<p>. getCollection ( collectionName );</p>

<p>}</p>

<p>}</p>

<p>BSONSerializer 때문에 Setter 를 제공할 필요가 없음</p>

<p>추가적인 행동</p>

<p>예를 들면 count() or size()</p>

<p>또는 리파지토리에서 애그리게잇 파트를 쿼리하는 것 (성능상 잇점)</p>

<p>하지만 이건 안티패턴이기 때문에 가능한 사용하지 않는 것이 좋다 (애그리게잇 법칙 위배)</p>

<p>만약 그게 당연시 하다고 느껴지면 애그리게잇을 분리하는 것도 한 방법</p>

<p>일반적으로 도메인 서비스 제어하가 어울린다.</p>

<p>하지만 너무 유스케이스에 최적화된 조회 메서드를 많이 제공한다면 악취일 수도 있다</p>

<p>그런 경우 CQRS 를 고려해보자</p>

<p>트랜잭션의 관리</p>

<p>트랜잭션 관리는 애플리케이션 계층의 책임이다. = 애플리케이션 서비스</p>

<p>트랜잭션 관리 방법</p>

<p>class ApplicationServiceFacade {</p>

<p>// 명식적인 트랜잭션</p>

<p>public void doSomeUseCaseTask1 () {</p>

<p>Transaction transaction = null ;</p>

<p>try {</p>

<p>transaction = this . session (). beginTransaction ();</p>

<p>// 도메인 모델을 사용한다.</p>

<p>transaction . commit ();</p>

<p>} catch ( Exception e ) {</p>

<p>if ( transaction ! null ) {</p>

<p>transaction . rollback ();</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>// 선언적인 트랜잭션</p>

<p>@Transactional</p>

<p>public void doSomeUseCaseTask2 () {</p>

<p>// 도메인 모델을 사용한다.</p>

<p>}</p>

<p>}</p>

<p>선언적인 방식이 더 낫다. 순수하게 도메인 로직에 위임하는 것에 집중할 수 있다.</p>

<p>관심사 분리!!</p>

<p>경고</p>

<p>단일 트랜잭션에서 여러 애그리게잇을 수정을 커밋하는 기능을 과도하게 사용하지 않도록 주의하라.</p>

<p>타입 계층구조</p>

<p>// 도메인 모델의 클라이언트</p>

<p>serviceProviderRepository . providerOf ( id )</p>

<p>. scheduleService ( date , description );</p>

<p>상위 타입(ServiceProvider )으로 처리</p>

<p>// 도메인 모델의 클라이언트</p>

<p>if ( id . identifiesWarble ()) {</p>

<p>serviceProviderRepository . warbleOf ( id )</p>

<p>. scheduleWarbleService ( date , warbleDescription );</p>

<p>} else if ( id . identifiesWonkle ()) {</p>

<p>serviceProviderRepository . wonkleOf ( id )</p>

<p>. scheduleWonkleService ( date , wonkleDescription );</p>

<p>}</p>

<p>하위 타입을 클라이언트에서 알고 분기 처리 해야하는 책임이 늘어난다.</p>

<p>위 코드는 전형적인 악취이다.</p>

<p>그러므로 상위타입은 하위타입에 대한 구분정보(type 속성)를 알고 있어야 한다.</p>

<p>그렇게 된다면 Repository 계층에서 캡슐화 시켜서 하위 타입 별 분기 처리를 할 수 있을 것이다.</p>

<p>@Entity</p>

<p>class ServiceProvider {</p>

<p>...</p>

<p>private ServiceType type ;</p>

<p>public void scheduleService ( Date date , ServiceDescription description ) {</p>

<p>if ( type . isWarble ()) {</p>

<p>this . scheduleWarbleSevice ( date , description );</p>

<p>} else if ( type . isWonkle ()) {</p>

<p>this . scheduleWonkleService ( date , description );</p>

<p>} else {</p>

<p>this . scheduleCommonService ( date , description );</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>나라면 위의 경우에서도 ServiceType 으로 위임해서 if 문을 제거했을 것 같다.</p>

<p>리파지토리 대 데이터 액세스 객체</p>

<p>Repository != DAO</p>

<p>리파지토리 : 객체 지향 > with 도메인 모델 패턴</p>

<p>DAO : 데이터 지향 > with 트랜잭션 스크립트 패턴</p>

<p>SMART DAO는 DDD 입장에서는 안티패턴</p>

<p>SMART DAO는 도메인 로직이 DB 쿼리나 DB의 프로시저에 존재하는 경우를 말함</p>

<p>중요한 것은 데이터 액세스 지향보다는 컬렉션 지향으로 설계하려고 노력해야하는 점</p>

<p>리파지토리의 테스트</p>

<p>실제 인프라와 연동하는 테스트 (실제 DB와 통신)</p>

<p>인메모리로 연동하는 테스트</p>

<p>개인적으로 실제 인프라와 연동하는 것이 중요하다고 봄.</p>

<p>인메모리 구현으로 테스트하기</p>

<p>Skip</p>

<p>마무리</p>

<p>컬랙션 지향 VS 영속성 지향</p>

<p>리파지토리의 추가적인 행동 (count() )</p>

<p>트랜잭션 처리</p>

<p>타입 계층과 리파지토리</p>

<p>Repository vs DAO</p>

<p>테스트</p>

<p>IDDD 12장. 리파지토리 was originally published by MJ at DevOOOOOOOOP on June 10, 2018.</p>

<p>source : http://redutan.github.io/2018/06/10/IDDD-chapter12</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>

                  
                </div>
                <nav class="page-navigation entry-navigation pagination content-nav">
                  <ul class="page-navigation-list">

                    <li class="page-navigation-list-item page-navigation-prev"><a rel="prev" href="https://weblog.youre.space/redutan/2018/06/000947.html" title="IDDD 111장. 팩토리">Previous entry</a></li>


                    <li class="page-navigation-list-item page-navigation-next"><a rel="next" href="https://weblog.youre.space/redutan/2018/07/001043.html" title="IDDD 6장. 값 객체">Next entry</a></li>

                  </ul>
                </nav>
                <!--
<aside id="zenback" class="zenback feedback">
  
    Please paste Zenback script code here.
  
</aside>
-->
                
                <aside id="trackbacks" class="trackbacks feedback">
  <h2>TrackBacks</h2>
  
  <p id="trackback-url">TrackBack URL: https://connexus.youre.space/mt6/mt-tb.cgi/319</p>
  
  
</aside>


              </article>
            </div>
            <aside class="widgets related" role="complementary">
              <nav class="widget-search widget">
  <div class="widget-content">
    <form method="get" id="search" action="https://connexus.youre.space/mt6/mt-search.cgi">
      <div>
        <input type="text" name="search" value="" placeholder="Search...">

        <input type="hidden" name="IncludeBlogs" value="17">

        <input type="hidden" name="limit" value="20">
        <button type="submit" name="button">
          <img alt="Search" src="https://connexus.youre.space/mt-static/support/theme_static/rainier/img/search-icon.png">
        </button>
      </div>
    </form>
  </div>
</nav>
<nav class="widget-archive-dropdown widget">
  <h3 class="widget-header">Archives</h3>
  <div class="widget-content">
    <select>
      <option>Select a Month...</option>
    
      <option value="https://weblog.youre.space/redutan/2018/07/">July 2018</option>
    
  
    
      <option value="https://weblog.youre.space/redutan/2018/06/">June 2018</option>
    
  
    
      <option value="https://weblog.youre.space/redutan/2018/05/">May 2018</option>
    
  
    
      <option value="https://weblog.youre.space/redutan/2018/04/">April 2018</option>
    
  
    
      <option value="https://weblog.youre.space/redutan/2018/02/">February 2018</option>
    
    </select>
  </div>
</nav>
    
  

<div class="widget-syndication widget section">
  <div class="widget-content">
    <p><img src="https://connexus.youre.space/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="https://weblog.youre.space/redutan/atom.xml">Subscribe to this blog's feed</a></p>

  </div>
</div>

            </aside>
          </div>
        </div>
        <footer id="footer" role="contentinfo">
          <div id="footer-inner">
            <div id="footer-content">
  <nav role="navigation">
          <ul>
            <li><a href="https://weblog.youre.space/redutan/">Home</a></li>


          </ul>
        </nav>

  <p class="license">&copy; Copyright 2019.</p>
  <p class="poweredby">Powered by <a href="http://www.movabletype.org/">Movable Type</a></p>
</div>
          </div>
        </footer>
      </div>
    </div>
    <script src="https://connexus.youre.space/mt-static/jquery/jquery.min.js"></script>
    <script src="https://weblog.youre.space/redutan/mt-theme-scale2.js"></script>
  </body>
</html>
