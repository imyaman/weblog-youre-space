<!DOCTYPE html>
<html lang="en-us" itemscope itemtype="http://schema.org/Blog">
  <head>
    <meta charset="UTF-8">
    
    <title>redutan</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="https://weblog.youre.space/redutan/styles.css">
    <!--[if lt IE 9]>
    <link rel="stylesheet" href="https://weblog.youre.space/redutan/styles_ie.css">
    <script src="https://weblog.youre.space/mt-static/support/theme_static/rainier/js/html5shiv.js"></script>
    <![endif]-->
    
    <link rel="start" href="https://weblog.youre.space/redutan/">
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="https://weblog.youre.space/redutan/atom.xml" />
    <link rel="canonical" href="https://weblog.youre.space/redutan/" />
    <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-102177098-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


    <!-- Open Graph Protocol -->
    <meta property="og:type" content="article">
    <meta property="og:locale" content="en-us">
    <meta property="og:title" content="redutan">
    <meta property="og:url" content="https://weblog.youre.space/redutan/">
    
    <meta property="og:site_name" content="redutan">
    <meta property="og:image" content="https://weblog.youre.space/mt-static/support/theme_static/rainier/img/siteicon-sample.png">
    <!-- Microdata -->
    
    <meta itemprop="name" content="redutan">
    <link itemprop="url" href="https://weblog.youre.space/redutan/">
    <link itemprop="image" href="https://weblog.youre.space/mt-static/support/theme_static/rainier/img/siteicon-sample.png">
  </head>
  <body>
    <div id="container">
      <div id="container-inner">
        <header id="header" role="banner">
          <div id="header-inner">
            <div id="header-content">
              <h1>
                <a href="https://weblog.youre.space/redutan/">

                  redutan

                </a>
              </h1>
              
            </div>

            <nav role="navigation">
          <ul>
            <li><a href="https://weblog.youre.space/redutan/">Home</a></li>


          </ul>
        </nav>

          </div>
        </header>
        <div id="content">
          <div id="content-inner">
            <div id="index-main" class="main" role="main">

              <article id="entry-1048" class="entry-asset entry asset hentry" itemscope itemType="http://schema.org/BlogPosting">
  <div class="asset-header">
    <h2 class="asset-name entry-title" itemprop="name"><a href="https://weblog.youre.space/redutan/2018/07/001048.html">IDDD 14장. 애플리케이션</a></h2>
    <footer class="asset-meta">
      <ul class="asset-meta-list">
        <li class="asset-meta-list-item">Posted on <time datetime="2018-07-13T07:26:51+09:00" itemprop="datePublished">July 13, 2018</time></li>
        <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

      </ul>
    </footer>
  </div>
  <div class="asset-content entry-content" itemprop="articleBody">
    <p>사용자 인퍼페이스와 도메인 모델 사이에 위치</p>

<p>유스케이스 태스크를 조정</p>

<p>트랜잭션, 보안 권한 부여 담당</p>

<p>애플리케이션을 핵심 도메인 모델과 상호 교류하며 이를 지원하기 위해 잘 조합된 컴포넌트의 집합을 의미하기 위해 사용하고 있다.</p>

<p>이는 일반적으로 도메인 모델 그 자체와 사용자 인터페이스, 내부적으로 사용되는 애플리케이션 서비스, 인프라적 컴포넌트를 뜻한다.</p>

<p>이 각각의 영역에 어떤 것들이 들어가는지는 애플리케이션마다 다르며, 사용하는 아키텍처가 무엇인지에 따라서도 달라진다.</p>

<p>그림 14.1 특정한 한 가지 아키텍처에 국한되지 않은 주요 애플리케이션 영역. 여전히 각기 다른 영역의 추상화에 의존적인 인프라의 DIP를 강조한다.</p>

<p>ui.Controller -구현-> infra.TomcatController -위임-> application.Service -구현-> infra.TransactionalService -위임-> domain.Repository -구현-> infra.JpaRepository -의존-> infra.Mysql</p>

<p>필자는 UI -> Appcliation -> Infra 순서로 설명해 나간다. (Top-Down 방식)</p>

<p>사용자 인터페이스</p>

<p>UI 종류</p>

<p>Web 1.0 렌더링 되는 HTML</p>

<p>Web 2.0 DHTML + Ajax</p>

<p>데스크톱 애플리케이션 + HTTP 통신</p>

<p>도메인 객체의 렌더링</p>

<p>그림 14.2 조회 시에는 복수 의 애그리게잇. 명령 시에는 한 개의 애그리게잇</p>

<p>애그리게잇 인스턴스로부터 데이터 전송 객체를 렌더링하기</p>

<p>DTO + Assembler</p>

<p>개인적으로 가장 선호하는 방식</p>

<p>애그리게잇 내부 상태를 발행하기 위해 중재자를 사용하자</p>

<p>중재자 패턴</p>

<p>개인적으로 비추 도메인 모델이 (약하긴 하지만) UI에 의존하게 됨</p>

<p>도메인 페이로드 객체로부터 애그리게잇 인스턴스를 렌더링하라</p>

<p>도메인 객체를 내부에 담고 있는 DPO(Domain Payload Object)로 렌더링 하는 방식</p>

<p>지연로딩 이슈가 있기 때문에 OSIV와 같은 기술과 함께 쓰길 권장한다.</p>

<p>애그리게잇 인스턴스의 상태 표현</p>

<p>View Model? Presentation Model?</p>

<p>DTO와 차이점을 모르겠다. 상태를 표현한다는 것으로 보아 불변이 가능한 정도 차이인 것인가?</p>

<p>유스케이스 최적 리파지토리 쿼리</p>

<p>특정 유스케이스에 특화된 쿼리 메소드 제공.</p>

<p>CQRS와 구분하자.</p>

<p>다수의 개별 클라이언트 처리하기</p>

<p>이건 SKIP 하자. 최근의 MVC 프레임워크에서 지원하므로 Application의 책임이 아니라고 본다.</p>

<p>변환 어댑터와 사용자 편집의 처리</p>

<p>Adapter + Command (Or Presentation Model)</p>

<p>주로 명령(편집, 수정) 시에 사용하는 방식</p>

<p>애플리케이션 서비스</p>

<p>애플리케이션 서비스를 얇게 유지(파사드)</p>

<p>도메인 모델로 위임</p>

<p>애플리케이션 서비스 예제</p>

<p>원시타입의 나열 VS 인자 (커맨드) 객체</p>

<p>원시타입이 너무 많이 나열되면 그것은 안티패턴이라고 보고 가능하면 인자(Or 커맨드)로 캡슐화 하는 것이 좋아 보인다.</p>

<p>단순 인자이며 명령을 캡슐화 하지 못하는데 커맨드 패턴이라고 부르는 것이 어색해 보인다.</p>

<p>package com . saasovation . identityaccess . application ;</p>

<p>class TenantIdentityService {</p>

<p>@Transactional // 트랜잭션과 보안 처리</p>

<p>@PreAuthorize ( "hasRole('SubscriberRepresentative')" )</p>

<p>public void activeTenant ( TenantId tenantId ) {</p>

<p>// 도메인 모델로 위임</p>

<p>this . nonNullTenant ( tenant ). activate ();</p>

<p>}</p>

<p>@Transactional ( readOnly = true )</p>

<p>public Tenant nonNullTenant ( TenantId tenantId ) {</p>

<p>Tenant tenant = this . tenant ( tenantId );</p>

<p>if ( tenant == null ) {</p>

<p>throw new IllegalArgumentException ( "Tenant does not exists" );</p>

<p>}</p>

<p>return tenant ;</p>

<p>}</p>

<p>}</p>

<p>결합이 분리된 서비스 출력</p>

<p>@Override</p>

<p>@Transactional ( readOnly = true )</p>

<p>public void findTenant ( TenantId tenantId ) {</p>

<p>Tenant teannt =</p>

<p>this . tenantRepository . tenantOfId ( tenantId )</p>

<p>this . tenantIdentityOutputPort (). write ( tenant );</p>

<p>}</p>

<p>최근 추세는 어쨋든 사용자에게 출력에 대한 책임은 가능한 UI가 하는 것이 좋다고 본다.</p>

<p>이는 애플리케이션의 책임이 아닌 것 같다.</p>

<p>그러한 것은 컴포넌트로 추상화 해서 UI 모듈에 있는 것이 더 어울리는 것 같다. 개인적으로 출력은 반환 값이 있는 것이 더 직관적으로 보인다.</p>

<p>여러 바운디드 컨텍스트 묶기</p>

<p>그림 14.3 UI에서 다수의 모델을 구성해야만 할 때가 있다. 이 그림에서는 하나의 애플리케이션 계층을 사용해서 세 개의 모델을 구성한다.</p>

<p>애플리케이션 계층이 유스케이스 를 관리 - UI 계층이 아니다!!</p>

<p>제품, 토론, 리뷰 컨텍스트가 분리 VS 하나의 컨텍스트로 통합 > 결론은 모델 정제!!</p>

<p>개인적으로 이러한 상황에서는 UI에서 각각 쿼리 해서 조합하던가, API-GW에서 조합하는 것이 좋다고 본다.</p>

<p>물론 특정 컨텍스트 내에서 조합해야 한다면 애플리케이션 서비스 가 가장 어울리는 장소인 것 같다.</p>

<p>인프라</p>

<p>그림 14.4 애플리케이션 서비스는 도메인 모델의 리파지토리 인터페이스에 의존적이지만, 인프라의 구현 클래스를 사용한다. 패키지는 넓은 범위의 책임을 캡슐화 한다</p>

<p>엔터프라이즈 컴포넌트 컨테이너</p>

<p>EJB VS Spring</p>

<p>마무리</p>

<p>도메인 모델 -> UI 모델</p>

<p>사용자 입력 -> 도메인 모델</p>

<p>애플리케이션 서비스의 책임</p>

<p>DIP로 도메인 모델과 기술(인프라) 분리 및 유연성 확보</p>

<p>IDDD 14장. 애플리케이션 was originally published by MJ at DevOOOOOOOOP on June 19, 2018.</p>

<p>source : http://redutan.github.io/2018/06/19/IDDD-chapter14</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>

  </div>
  <div class="entry-more-link">
    <a href="https://weblog.youre.space/redutan/2018/07/001048.html" itemprop="url">Continue reading</a>
  </div>
</article>


              <article id="entry-1045" class="entry-asset entry asset hentry" itemscope itemType="http://schema.org/BlogPosting">
  <div class="asset-header">
    <h2 class="asset-name entry-title" itemprop="name"><a href="https://weblog.youre.space/redutan/2018/07/001045.html">IDDD 7장. 서비스</a></h2>
    <footer class="asset-meta">
      <ul class="asset-meta-list">
        <li class="asset-meta-list-item">Posted on <time datetime="2018-07-13T07:26:48+09:00" itemprop="datePublished">July 13, 2018</time></li>
        <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

      </ul>
    </footer>
  </div>
  <div class="asset-content entry-content" itemprop="articleBody">
    도메인 서비스 : 도메인 모델 내 무상태 오퍼레이션 제공

애그리게잇이나 값 객체의 행위로써 어울리지 않는 것

before

class Product {

Set  backlogItems ;

BusinessPriorityTotals businessPriorityTotals () {

//...

}

}

모델 정제를 통해 Set backlogItems 를 분리

그렇다면 businessPriorityTotals() 메서드는 어떻게 되는가?

after

class Product {

static BusinessPriorityTotals businessPriorityTotals (

Set  aBacklogItems ) {

// ...

}

}

정적 메소드로 변경 - 하지만 과연 이것은 옳은가?

도메인 서비스 가 필요한 시점이다!

도메인 서비스란 무엇인가

하지만 그보다 먼저 도메인 서비스가 아닌 것은 무엇인가?

도메인 서비스 : 도메인 로직이 있다.

애플리케이션 서비스 : 도메인 로직이 없다. (보안, 트랜잭션 등)

정의

엔터티나 값객체의 책임이 아닌 (도메인적) 행위

유비쿼터스 언어로써 표현

무상태!

예시

중요 비즈니스 프로세스

복수 개 의 도메인 객체에서 필요로 하는 계산

한 조합에서 다른 조합으로 도메인 객체를 변형 할 때

서비스가 필요할지 확인하자

도메인 특화 지식은 클라이언트로 절대 유촐돼선 안된다.(클라이언트가 애플리케이션 서비스일지라도)

도메인 객체에 위치 시키기 애매하면 도메인 서비스 에 담는다.

주의 : 도메인 서비스를 남용하면 빈약한(Anemic) 도메인 모델이 된다.

도메인에서 서비스를 모델링하기

AuthenticationService

package com . saasovation . identityaccess . domain . model . identity ; // !!

interface AuthenticationService {

UserDescriptor authenticate (

TenantId tenantId ,

String username ,

Strin password );

}

EncryptionAuthenticationService

package com . saasovation . identityaccess . infra . services ; // !!

class EncryptionAuthenticationService implements AuthenticationService {

@Override

UserDescriptor authenticate (

@NonNull TenantId tenantId ,

@NonNull String username ,

@NonNull Strin password ) {

Tenant tenant = tenantRepository . findById ( tenantId );

if ( tenant == null || ! tenant . isActive ()) {

throw new TenantNotFoundException ( tenantId );

}

String encryptedPassword =

encryptService . encryptedValue ( passwod ); // 암호화 책임도 도메인 서비스?

User user = userRepository . findByTenantAndUsernameAndPassword (

tenant , username , encryptedPassword );

if ( user == null || ! user . isEnabled ()) {

throw new UserNotFoundException ( username );

}

return user . userDescriptor ();

}

}

분리된 인터페이스가 꼭 필요할까

다형성이 요구되지 않는다면 굳이 분리된 인터페이스는 필요하지 않다고 본다.

다형성 등으로 인한 추상화가 요구될 때 분리된 인터페이스로 리팩토링 하자

생각 : 구현클래스에 Impl 접미사를 붙이는 것은 가능하면 피하는 것이 좋다고 본다.

DI 프레임워크(ex:Spring)를 사용하면 분리된 인터페이스를 사용하기 더 편하다.

계산 프로세스

생각 : 계산(연산)은 변하지 않는 행동이므로 분리된 인터페이스 는 필요하지 않다.

대부분 경우 계산 프로세스를 정적 메서드 로 해결하는 경향이 많다.

이는 잘못된 행동이며 계산이 도메인 로직을 표현한다면 당연히 도메인 모델 내에 도메인 서비스로써 존재 해야 한다.

참고 : p.369 ~ 371 소스코드

변환 서비스

타 서비스와 통합을 위해 사용

이것도 도메인 서비스 였다니

Adapter

package com . saasovation . collaboration . infra . services ;

class UserInRoleAdapter {

 T toCollaborator (

Tenant tenant , String identity , String role ,

Class  collaboratorClass );

}

Translator

package com . sasovation . collaboration . infra . services ;

class CollbaratorTransaltor {

 T toCollaboratorFrom (

String json , Class  collaboratorClass );

}

생각 : translator도 도메인 서비스 인가?

도메인 서비스의 미니 계층 사용하기

가능하면 미니 계층은 사용하지 말자 - 안티패턴!

하지만 필요하다면 특정 도메인만 제한적으로 사용하는 것도 좋다.

마무리

도메인 서비스는 필요할 때 사용

남용하면 빈약한 도메인 모델화

무상태

VS 애플리케이션 서비스

IDDD 7장. 서비스 was originally published by MJ at DevOOOOOOOOP on May 18, 2018.

source : http://redutan.github.io/2018/05/18/IDDD-chapter07<br />---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW

  </div>
  <div class="entry-more-link">
    <a href="https://weblog.youre.space/redutan/2018/07/001045.html" itemprop="url">Continue reading</a>
  </div>
</article>


              <article id="entry-1043" class="entry-asset entry asset hentry" itemscope itemType="http://schema.org/BlogPosting">
  <div class="asset-header">
    <h2 class="asset-name entry-title" itemprop="name"><a href="https://weblog.youre.space/redutan/2018/07/001043.html">IDDD 6장. 값 객체</a></h2>
    <footer class="asset-meta">
      <ul class="asset-meta-list">
        <li class="asset-meta-list-item">Posted on <time datetime="2018-07-13T07:26:46+09:00" itemprop="datePublished">July 13, 2018</time></li>
        <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

      </ul>
    </footer>
  </div>
  <div class="asset-content entry-content" itemprop="articleBody">
    <p>가능한 엔터티 대신 값 객체를 사용해 모델링하도록 노력해야 한다.</p>

<p>특성만 신경 쓴다면 이를 값 객체로 분리하라. 특성의 의미를 표현하고 기능도 부여하자. 불변성. 식별자는 필요 없고, 설계의 복잡성을 줄여준다.</p>

<p>값의 특징</p>

<p>개념을 값으로</p>

<p>측정, 수량화, 설명</p>

<p>불변성(no side-effect)</p>

<p>개념적 전체</p>

<p>변경 대신 대치</p>

<p>등가성(value equality:동등성)</p>

<p>유비쿼터스 언어로써 표현하는 값이어야함</p>

<p>측정, 수량화, 설명</p>

<p>날짜와 시간, 나이, 통화, 주소, 도형, …</p>

<p>불변성</p>

<p>No Setter</p>

<p>하지만 완벽하진 않다. 방어 복사가 필요할 수 있음 (final 일지라도 불변은 깨질 수 있다.)</p>

<p>개념적 전체</p>

<p>주소 = 우편번호 + 기본주소 + 상세주소</p>

<p>돈 = 500(수량) + 달러(통화)</p>

<p>Bad Case</p>

<p>class ThingOfWorth { // 가치 있는 것</p>

<p>private String name ;</p>

<p>private BigDecimal amount ;</p>

<p>private String currency ;</p>

<p>}</p>

<p>Good Case</p>

<p>class ThingOfWorth { // 가치 있는 것</p>

<p>private ThingName name ; // !!</p>

<p>private MonetaryValue worth ; // 가치</p>

<p>}</p>

<p>@Value</p>

<p>class MonetraryValue {</p>

<p>private BigDecimal amount ;</p>

<p>private Currency currency ;</p>

<p>}</p>

<p>ThingName 으로 값 객체로 만들어서 name의 기능을 중앙화 시킬 수 있다. (도메인 로직을 안으로 품을 수 있음)</p>

<p>대체성</p>

<p>값은 변경이 불가능하므로 값 참조를 다른 값으로 바꾸는 것을 말함</p>

<p>FullName name = new FullName ( "Myeongju" , "Jung" );</p>

<p>// ...</p>

<p>name = new FullName ( "Jiwon" , "M" , "Jung" );</p>

<p>값 등가성</p>

<p>equals(), hasoCode()</p>

<p>엔터티로 설계된 개념이 식별자가 필요하지 않다면 값 객체 로 모델링하자.</p>

<p>부작용이 없는 행동</p>

<p>만약 값객체에 행위가 없다면, 좋은 설계인지 의심하라</p>

<p>Getter : No side-effect</p>

<p>Setter : With side-effect</p>

<p>FullName name = new FullName ( "Myeongju" , "Jung" );</p>

<p>// ...</p>

<p>name = name . withMiddleInitial ( "M" );</p>

<p>FullName withMiddleInitial ( String middleName ) {</p>

<p>return new FullName ( this . firstName , middleName , this . lastName );</p>

<p>}</p>

<p>값 객체의 매개변수로 값만 전달하자.</p>

<p>만약 엔터티와 같은 가변성을 가지는 인자를 받는다면 부작용이 발생할 가능성 이 생긴다.</p>

<p>아니면 Getter만 제공하는 추상화된 인자를 받는 것도 좋은 방법이다. > Entity에 Getter만 있는 인터페이스를 Mixin</p>

<p>기본 언어 값 타입에는 도메인에 맞춘 부작용이 없는 함수를 할당할 수 없다</p>

<p>도메인적인 표현이 기본 언어 함수에서 제공할 수 있을리가 없다.</p>

<p>미니멀리즘으로 통합하기</p>

<p>ACL 내에서는 조회용으로써 일부 특성과 행위가 요구된다.</p>

<p>즉 Entity 전체가 필요한(순응자나 공유모델) 것이 아니라, 해당 컨택스트 내에서 어울리는 타입으로써 값 객체가 좋은 선택</p>

<p>값으로 표현되는 표준 타입</p>

<p>표준 타입에는 Enum을 쓰는 것이 좋다</p>

<p>잘 이해가 안된다 ㅠㅠ</p>

<p>값 객체의 테스트</p>

<p>클라이언트 관점에서 값 객체를 보는 것은 중요하다.</p>

<p>불변성을 테스트 해야 한다.</p>

<p>테스트를 통해서 도메인적 표현을 확인할 수 있어야 한다.</p>

<p>구현</p>

<p>불변, 불변, 불변 (No Setter)</p>

<p>equals() , hashCode() , toString()</p>

<p>JPA를 위해서 빈 생성자는 필수 (PACKAGE 접근제어로 생성)</p>

<p>보호절을 통한 불변식 강제</p>

<p>값 객체의 저장</p>

<p>데이터 모델 누수의 부정적 영향을 거부하라</p>

<p>도메인 모델을 위해서 데이터 모델을 설계해야한다.</p>

<p>ORM 구현</p>

<p>오래된 내용이라서 SKIP. 이젠 Spring Data Jpa 를 사용하자.</p>

<p>마무리</p>

<p>값 객체 특징, 사용, 구현</p>

<p>IDDD 6장. 값 객체 was originally published by MJ at DevOOOOOOOOP on May 15, 2018.</p>

<p>source : http://redutan.github.io/2018/05/15/IDDD-chapter06</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>

  </div>
  <div class="entry-more-link">
    <a href="https://weblog.youre.space/redutan/2018/07/001043.html" itemprop="url">Continue reading</a>
  </div>
</article>


              <article id="entry-963" class="entry-asset entry asset hentry" itemscope itemType="http://schema.org/BlogPosting">
  <div class="asset-header">
    <h2 class="asset-name entry-title" itemprop="name"><a href="https://weblog.youre.space/redutan/2018/07/000963.html">IDDD 12장. 리파지토리</a></h2>
    <footer class="asset-meta">
      <ul class="asset-meta-list">
        <li class="asset-meta-list-item">Posted on <time datetime="2018-07-13T07:25:27+09:00" itemprop="datePublished">July 13, 2018</time></li>
        <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

      </ul>
    </footer>
  </div>
  <div class="asset-content entry-content" itemprop="articleBody">
    <p>전역(global) 액세스가 필요한 각 객체의 타입이다, 해당 타입의 모든 객체가 담긴 인메모리 컬렉션이란 허상을 제공하는 객체를 생성하자.</p>

<p>잘 알려진 전역의 인터페이스를 통한 액세스를 설정하자.</p>

<p>객체를 추가하거나 제거하는 메소드를 제공하자…</p>

<p>일정 조건에 부합되는 특성을 갖는 객체를 선택해 완전히 인스턴스화된 객체나 여러 객체의 컬렉션으로 반환하는 메소드를 제공하자…</p>

<p>애그리게잇에 대해서만 리파지토리를 제공하자.. [Evans]</p>

<p>애그리게잇 : 리파지토리 = 1(..N):1</p>

<p>컬렉션 지향 리파지토리</p>

<p>package java . util ;</p>

<p>public interface Collection {</p>

<p>public boolean add ( Object o );</p>

<p>public boolean addAll ( Collection c );</p>

<p>public boolean remove ( Object o );</p>

<p>public boolean removeAll ( Collection c );</p>

<p>}</p>

<p>같은 인스턴스를 두번 추가되도록 허용해서는 안된다.</p>

<p>재저장 을 할 필요가 없다.</p>

<p>그저 객체의 상태를 변경시키면 자동으로 저장될 뿐이다.</p>

<p>결국 Set 처럼 행동해야 한다.</p>

<p>재저장 할 필요가 없다면 객체의 상태를 추적해야한다.</p>

<p>영속성 매커니즘의 암시적 변경 추적 기법</p>

<p>암시적 읽기 시 복사(Copy-on-Read) : 읽을 때 복사본을 만들어 두고 복사본과 비교해서 변경된 것이 있으면 Commit 시킨다.</p>

<p>암시적 쓰기 시 복사(Copy-on-Write) : 프록시로 감싸두고 Dirty(상태 변경이 되면)인 경우 Commit 시킨다.</p>

<p>하이버네이트 구현</p>

<p>package com . saasovation . collaboration . domain . model . calendar ; //!!</p>

<p>interface CalendarEntryRepository {</p>

<p>void add ( CalendarEntry calendarEntry );</p>

<p>void addAll ( Collection  calendarEntries );</p>

<p>void remove ( CalendarEntry calendarEntry );</p>

<p>void removeAll ( Collection  calendarEntries );</p>

<p>CalendarEntry calendarEntryOfId ( Tenant tenant , CalendarEntriyId id );</p>

<p>Collection  calendarEntriesOfCalendar (</p>

<p>Tenant tenant , CalendarId calendarId );</p>

<p>Collection  overlappingCalendarEntries (</p>

<p>Tenant tenant , CalendarId calendarId , TimeSpan timeSpan );</p>

<p>CalendarEntryId nextIdentity ();</p>

<p>}</p>

<p>package 는 도메인 모델과 함께한다.</p>

<p>물리적 삭제 VS 논리적 삭제</p>

<p>package com . saasovation . collaboration . infrastructure . persistence ;</p>

<p>public class HibernateCalendarEntryRepository</p>

<p>implements CalendarEntryRepository {</p>

<p>private final SpringHibernateSessionProvider sessionProvider ;</p>

<p>public HibernateCalendarEntryRepository (</p>

<p>SpringHibernateSessionProvider sessionProvider ) {</p>

<p>this . sessionProvider = sessionProvider ;</p>

<p>}</p>

<p>private org . hibernate . Session session () {</p>

<p>return this . sessionProvider . session ();</p>

<p>}</p>

<p>@Override</p>

<p>public void add ( CalendarEntry calendarEntry ) {</p>

<p>this . session (). saveOrUpdate ( calendarEntry );</p>

<p>}</p>

<p>@Override</p>

<p>public void addAll ( Collection  calendarEntries ) {</p>

<p>for ( CalendarEntry each : calendarEntries ) {</p>

<p>this . session (). saveOrUpdate ( each );</p>

<p>}</p>

<p>}</p>

<p>@Override</p>

<p>public void remove ( CalendarEntry calendarEntry ) {</p>

<p>this . session (). delete ( calendarEntry );</p>

<p>}</p>

<p>@Override</p>

<p>public void removeAll ( Collection  calendarEntries ) {</p>

<p>for ( CalendarEntry each : calendarEntries ) {</p>

<p>this . session (). delete ( each );</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>package : infrastructure.persistence</p>

<p>Set 과 유사한 행위 제공</p>

<p>Cascade 를 통한 연관된 엔터티를 같이 변경하는 기능도 있음</p>

<p>복잡한 조회의 경우 HQL을 이용</p>

<p>하지만 JPA를 사용한다면 JPQL을 사용하나, 현재까지는 querydsl 과 같은 기술이 좋은 것 같다.</p>

<p>탑링크 구현에 대한 고려</p>

<p>탑링크는 명시적으로 작업단위(Unit of work) 를 지정할 수 있다.</p>

<p>일종의 트랜잭션의 범위를 추상화 시킨 것</p>

<p>Calendar calendar = session . readObject (...);</p>

<p>UnitOfWork work = session . acquireUnitOfWork ();</p>

<p>Calendar calendarToRename = work . registerObject ( calendar );</p>

<p>calendarToRename . rename ( "CollabOvation Project Calendar" );</p>

<p>work . commit ();</p>

<p>package com . saasovation . collaboration . infrastructure . persistence ;</p>

<p>public class ToplinkCalendarEntryRepository</p>

<p>implements CalendarEntryRepository {</p>

<p>@Override</p>

<p>public void add ( Calendar calendar ) {</p>

<p>this . unitOfWork (). registerNewObject ( calendar );</p>

<p>}</p>

<p>@Override</p>

<p>public void editingCopy ( Calendar calendar ) {</p>

<p>return ( Calendar ) this . unitOfWork (). registerObject ( calendar );</p>

<p>}</p>

<p>}</p>

<p>영속성 지향의 리파지토리</p>

<p>컬렉션 지향 리파지토리 : Set</p>

<p>영속성 지향 리파지토리 : HashMap</p>

<p>하지만 꼭 put 를 해야한다. - 원자적 쓰기를 통제할 수 없음(트랜잭션 없음)</p>

<p>No-Sql 종류가 많다.</p>

<p>잼파이어</p>

<p>코히어런스</p>

<p>몽고DB</p>

<p>리악</p>

<p>코히어런스 구현</p>

<p>package com . saasovation . agilepm . domain . model . product ;</p>

<p>interface ProductRepository {</p>

<p>ProductId nextIdentity ();</p>

<p>Collection  allProductsOfTenant ( Tenant tenant );</p>

<p>Product productOfId ( Tenant tenant , ProductId productId );</p>

<p>void remove ( Product product );</p>

<p>void removeAll ( Collection  products );</p>

<p>void save ( Product product );</p>

<p>void saveAll ( Collection  products );</p>

<p>}</p>

<p>package com . saasovation . agilepm . infrastructure . persistence ;</p>

<p>class CoherenceProductRepository</p>

<p>implements ProductRepository {</p>

<p>private Map  caches ;</p>

<p>public CoherenceProductRepository () {</p>

<p>this . caches = new HashMap >();</p>

<p>}</p>

<p>private synchronized NamedCache ( TenantId tenantId ) {</p>

<p>NamedCache cache = this . caches . get ( tenantId );</p>

<p>if ( cache == null ) {</p>

<p>// ageilepm:Product:TenantId</p>

<p>// 1단계 : 2단계 : 3단계</p>

<p>cache = CacheFactory . getCache (</p>

<p>"agilepm.Product." + tenantId . id (),</p>

<p>Product . class . getClassLoader ());</p>

<p>this . caches . put ( tenantId , cache );</p>

<p>}</p>

<p>return cache ;</p>

<p>}</p>

<p>@Override</p>

<p>public void save ( Product product ) {</p>

<p>this . cache ( product . tenantId ())</p>

<p>. put ( this . idOf ( product ), product );</p>

<p>}</p>

<p>@Override</p>

<p>public void saveAll ( Collection  products ) {</p>

<p>Map  productsMap =</p>

<p>new HashMap >( products . size ());</p>

<p>for ( Product each : products ) {</p>

<p>if ( tenantId == null ) {</p>

<p>tenantId = product . tenantId ();</p>

<p>}</p>

<p>productsMap . put ( this . idOf ( product ), each );</p>

<p>}</p>

<p>this . cache ( tenantId ). putAll ( productsMap );</p>

<p>}</p>

<p>private String idOf ( Product product ) {</p>

<p>return this . idOf ( product . productId ());</p>

<p>}</p>

<p>private String idOf ( ProductId productId ) {</p>

<p>return productId . id ();</p>

<p>}</p>

<p>@Override</p>

<p>public void remove ( Product product ) {</p>

<p>this . cache ( product . tenantId ()). remove ( this . idOf ( product ));</p>

<p>}</p>

<p>@Override</p>

<p>public void removeAll ( Collection  products ) {</p>

<p>for ( Product each : products ) {</p>

<p>this . remove ( product );</p>

<p>}</p>

<p>}</p>

<p>@Override</p>

<p>public Collection  allProductsOfTenant ( Tenant tenant ) {</p>

<p>Set > entries =</p>

<p>this . cache ( tenant ). entrySet ();</p>

<p>Collection  products =</p>

<p>new HashSet ( entries . size ());</p>

<p>for ( Map . Entry  entry : entries ) {</p>

<p>products . add ( entry . getValue ());</p>

<p>}</p>

<p>return products ;</p>

<p>}</p>

<p>@Override</p>

<p>public Product productOfId ( Tenant tenant , ProductId productId ) {</p>

<p>return ( Product ) this . cache ( tenant ). get ( this . idOf ( productId ));</p>

<p>}</p>

<p>}</p>

<p>몽고DB 구현</p>

<p>애그리게잇을 -> 몽고DB포맷(직렬화), 몽고DB포맷 -> 애그리게잇(역직렬화)</p>

<p>몽고DB 문서의 고유 식별자(_id )</p>

<p>몽고DB 노드/클러스터 참조</p>

<p>class MongoProductRepository</p>

<p>extends MongoRepository </p>

<p>implements ProductRepository {</p>

<p>public MongoProductRepository () {</p>

<p>super ();</p>

<p>this . serializer ( new BSONSerializer ( Product . class ));</p>

<p>}</p>

<p>public ProductId nextIdentity () {</p>

<p>// 몽고DB에서 제공하는 식별자. _id 필드에 매핑시킬수 있음</p>

<p>return new ProductId ( new ObjectId (). toString ());</p>

<p>}</p>

<p>@Override</p>

<p>public void save ( Product product ) {</p>

<p>this . databaseCollection (</p>

<p>this . collectionName ( product . tenantId ()))</p>

<p>. save ( this . serialize ( product ));</p>

<p>}</p>

<p>protected String collectionName ( TenantId tenantId ) {</p>

<p>return "product" + tenantId . id ();</p>

<p>}</p>

<p>protected String databaseName () {</p>

<p>return "agilepm" ;</p>

<p>}</p>

<p>@Override</p>

<p>public Collection  allProductsOfTenant (</p>

<p>TenantId tenantId ) {</p>

<p>Collection  products = new ArrayList >();</p>

<p>DBCursor cursor =</p>

<p>this . databaseCollection (</p>

<p>this . databaseName (),</p>

<p>this . collectionName ( tenantId )). find ();</p>

<p>while ( curosr . hasNext ()) {</p>

<p>DBObject dbObject = cursor . next ();</p>

<p>Product product = this . deserialize ( dbObject );</p>

<p>products . add ( product );</p>

<p>}</p>

<p>return products ;</p>

<p>}</p>

<p>@Override</p>

<p>public Product productOfId (</p>

<p>TenantId tenantId , ProductId productId ) {</p>

<p>Product product = null ;</p>

<p>BasicDBObject query = new BasicDBObject ();</p>

<p>query . put ( "producetId" ,</p>

<p>new BasicDBObject ( "id" , productId . id ()));</p>

<p>DBCursor cursor =</p>

<p>this . databaseCollection (</p>

<p>this . databaseName (),</p>

<p>this . collectionName ( tenantId )). find ( query );</p>

<p>if ( cursor . hasNext ()) {</p>

<p>product = this . deserialize ( cursor . next ());</p>

<p>}</p>

<p>return product ;</p>

<p>}</p>

<p>}</p>

<p>class BSONSerializer  {</p>

<p>DBObject serialize ( String key , T object ) {</p>

<p>DBObject serialization = this . serialize ( object );</p>

<p>serialization . put ( "_id" , new ObjectId ( key ));</p>

<p>return serialization ;</p>

<p>}</p>

<p>}</p>

<p>abstract class MongoRepository  {</p>

<p>protected DBCollection databaseCollection (</p>

<p>String databaseName , String collectionName ) {</p>

<p>return MongoDatabaseProvider</p>

<p>. database ( databaseName )</p>

<p>. getCollection ( collectionName );</p>

<p>}</p>

<p>}</p>

<p>BSONSerializer 때문에 Setter 를 제공할 필요가 없음</p>

<p>추가적인 행동</p>

<p>예를 들면 count() or size()</p>

<p>또는 리파지토리에서 애그리게잇 파트를 쿼리하는 것 (성능상 잇점)</p>

<p>하지만 이건 안티패턴이기 때문에 가능한 사용하지 않는 것이 좋다 (애그리게잇 법칙 위배)</p>

<p>만약 그게 당연시 하다고 느껴지면 애그리게잇을 분리하는 것도 한 방법</p>

<p>일반적으로 도메인 서비스 제어하가 어울린다.</p>

<p>하지만 너무 유스케이스에 최적화된 조회 메서드를 많이 제공한다면 악취일 수도 있다</p>

<p>그런 경우 CQRS 를 고려해보자</p>

<p>트랜잭션의 관리</p>

<p>트랜잭션 관리는 애플리케이션 계층의 책임이다. = 애플리케이션 서비스</p>

<p>트랜잭션 관리 방법</p>

<p>class ApplicationServiceFacade {</p>

<p>// 명식적인 트랜잭션</p>

<p>public void doSomeUseCaseTask1 () {</p>

<p>Transaction transaction = null ;</p>

<p>try {</p>

<p>transaction = this . session (). beginTransaction ();</p>

<p>// 도메인 모델을 사용한다.</p>

<p>transaction . commit ();</p>

<p>} catch ( Exception e ) {</p>

<p>if ( transaction ! null ) {</p>

<p>transaction . rollback ();</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>// 선언적인 트랜잭션</p>

<p>@Transactional</p>

<p>public void doSomeUseCaseTask2 () {</p>

<p>// 도메인 모델을 사용한다.</p>

<p>}</p>

<p>}</p>

<p>선언적인 방식이 더 낫다. 순수하게 도메인 로직에 위임하는 것에 집중할 수 있다.</p>

<p>관심사 분리!!</p>

<p>경고</p>

<p>단일 트랜잭션에서 여러 애그리게잇을 수정을 커밋하는 기능을 과도하게 사용하지 않도록 주의하라.</p>

<p>타입 계층구조</p>

<p>// 도메인 모델의 클라이언트</p>

<p>serviceProviderRepository . providerOf ( id )</p>

<p>. scheduleService ( date , description );</p>

<p>상위 타입(ServiceProvider )으로 처리</p>

<p>// 도메인 모델의 클라이언트</p>

<p>if ( id . identifiesWarble ()) {</p>

<p>serviceProviderRepository . warbleOf ( id )</p>

<p>. scheduleWarbleService ( date , warbleDescription );</p>

<p>} else if ( id . identifiesWonkle ()) {</p>

<p>serviceProviderRepository . wonkleOf ( id )</p>

<p>. scheduleWonkleService ( date , wonkleDescription );</p>

<p>}</p>

<p>하위 타입을 클라이언트에서 알고 분기 처리 해야하는 책임이 늘어난다.</p>

<p>위 코드는 전형적인 악취이다.</p>

<p>그러므로 상위타입은 하위타입에 대한 구분정보(type 속성)를 알고 있어야 한다.</p>

<p>그렇게 된다면 Repository 계층에서 캡슐화 시켜서 하위 타입 별 분기 처리를 할 수 있을 것이다.</p>

<p>@Entity</p>

<p>class ServiceProvider {</p>

<p>...</p>

<p>private ServiceType type ;</p>

<p>public void scheduleService ( Date date , ServiceDescription description ) {</p>

<p>if ( type . isWarble ()) {</p>

<p>this . scheduleWarbleSevice ( date , description );</p>

<p>} else if ( type . isWonkle ()) {</p>

<p>this . scheduleWonkleService ( date , description );</p>

<p>} else {</p>

<p>this . scheduleCommonService ( date , description );</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>나라면 위의 경우에서도 ServiceType 으로 위임해서 if 문을 제거했을 것 같다.</p>

<p>리파지토리 대 데이터 액세스 객체</p>

<p>Repository != DAO</p>

<p>리파지토리 : 객체 지향 > with 도메인 모델 패턴</p>

<p>DAO : 데이터 지향 > with 트랜잭션 스크립트 패턴</p>

<p>SMART DAO는 DDD 입장에서는 안티패턴</p>

<p>SMART DAO는 도메인 로직이 DB 쿼리나 DB의 프로시저에 존재하는 경우를 말함</p>

<p>중요한 것은 데이터 액세스 지향보다는 컬렉션 지향으로 설계하려고 노력해야하는 점</p>

<p>리파지토리의 테스트</p>

<p>실제 인프라와 연동하는 테스트 (실제 DB와 통신)</p>

<p>인메모리로 연동하는 테스트</p>

<p>개인적으로 실제 인프라와 연동하는 것이 중요하다고 봄.</p>

<p>인메모리 구현으로 테스트하기</p>

<p>Skip</p>

<p>마무리</p>

<p>컬랙션 지향 VS 영속성 지향</p>

<p>리파지토리의 추가적인 행동 (count() )</p>

<p>트랜잭션 처리</p>

<p>타입 계층과 리파지토리</p>

<p>Repository vs DAO</p>

<p>테스트</p>

<p>IDDD 12장. 리파지토리 was originally published by MJ at DevOOOOOOOOP on June 10, 2018.</p>

<p>source : http://redutan.github.io/2018/06/10/IDDD-chapter12</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>

  </div>
  <div class="entry-more-link">
    <a href="https://weblog.youre.space/redutan/2018/07/000963.html" itemprop="url">Continue reading</a>
  </div>
</article>


              <article id="entry-947" class="entry-asset entry asset hentry" itemscope itemType="http://schema.org/BlogPosting">
  <div class="asset-header">
    <h2 class="asset-name entry-title" itemprop="name"><a href="https://weblog.youre.space/redutan/2018/06/000947.html">IDDD 111장. 팩토리</a></h2>
    <footer class="asset-meta">
      <ul class="asset-meta-list">
        <li class="asset-meta-list-item">Posted on <time datetime="2018-06-07T12:16:00+09:00" itemprop="datePublished">June  7, 2018</time></li>
        <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

      </ul>
    </footer>
  </div>
  <div class="asset-content entry-content" itemprop="articleBody">
    <p>애그리게잇을 생성하는 책임을 가지는 메소드나 객체를 말한다.</p>

<p>애그리게잇 생성을 캡슐화</p>

<p>도메인 모댈 내의 팩토리</p>

<p>복잡한 객체와 애그리게잇 인스턴스를 생성하는 책임을 별도의 객체로 이동시키자. 여기서의 책임은 도메인 모델과 관련이 있지 않지만, 여전히 도메인 설계를 구성하는 한 요소 다. 모든 복잡한 조립 과정을 캡슐화하고, 클라이언트가 인스턴스화된 객체의 구체적 클래스를 참조할 필요가 없도록 인터페이스를 제공하자. 전체 애그리게잇을 하나의 조각(원자성)으로 생성하고 고정자(Invariant)를 지정하자 [Evans]</p>

<p>팩토리 메소드 : 이 책은 주로 여기만 나옴</p>

<p>팩토리 객체(클래스)</p>

<p>애그리게잇 생성이 매우 복잡하고 다른 객체의 도움이 필요하면 클래스 분리를 하는 것이 좋은 것 같다.</p>

<p>가능한 팩토리 위치</p>

<p>애그리게잇 루트</p>

<p>정정 생성자를 통해서 도메인 의도가 나오면 더 좋다. static Task#forDraft()</p>

<p>아니면 상위 루트에서 하위 엔터리 생성도 가능 Project#createTask()</p>

<p>도메인 서비스 : 서비스 기반 팩토리</p>

<p>ProjectService#createProject()</p>

<p>팩토리 : 이 책은 다루지 않음</p>

<p>ProjectFactory#create()</p>

<p>애그리게잇 루트상의 팩토리 메소드</p>

<p>바운디드 컨텍스트</p>

<p>애그리게잇</p>

<p>팩토리 메소드</p>

<p>식별자와 액세스 컨텍스트</p>

<p>Tenant</p>

<p>offerRegisterationInvitation()</p>

<p>provisionGroup()</p>

<p>provisionRole()</p>

<p>registerUser()</p>

<p>협업 컨텍스트</p>

<p>Calendar</p>

<p>scheduleCalendarEntry()</p>

<p>Forun</p>

<p>startDiscussion()</p>

<p>Discussion</p>

<p>post()</p>

<p>애자일 PM 컨텍스트</p>

<p>Product</p>

<p>planBacklogItem()</p>

<p>scheduleRelease()</p>

<p>scheduleSprint()</p>

<p>CalendarEntry 인스턴스 생성하기</p>

<p>@Entity</p>

<p>class Calendar extends AbstractAggregateRoot {</p>

<p>CalendarEntry scheduleCalendarEntry (...) {</p>

<p>CalendarEntry calendarEntry = new CalendarEntry (...);</p>

<p>this . registerEvent ( new CalendarEntryScheduled (...));</p>

<p>return calendarEntry ;</p>

<p>}</p>

<p>}</p>

<p>유비쿼터스 언어에 부합되는 도메인이 표현됨 : scheduleCalendarEntry</p>

<p>보호절이 없다 : 어짜피 new CalendarEntry(...) 가 책임짐</p>

<p>Setter 를 사용하지 않는다. > 원자성 + 부수효과 줄어듬 + 불변식 강제 가 쉬움</p>

<p>이벤트 발행 : CalendarEntryScheduled</p>

<p>인자의 갯수가 줄어든다.</p>

<p>scheduleCalendarEntry(...) 에서는 11개가 요구되지만, new CalendarEntryScheduled(...) 에서는 9개로 줄어든다.</p>

<p>개인적으로는 이것도 인자를 캡슐화 시켜서 객체로 말아버리는 것이 좋은 것 같다. 9개의 인자라도 너무 많은 것 같음.</p>

<p>하지만</p>

<p>CalendarEntry 를 생성하기 위해서는 꼭 Calendar 인스턴스 가 요구됨</p>

<p>이는 DB 조회라는 부하가 추가됨</p>

<p>Discussion 인스턴스 생성하기</p>

<p>@Entity</p>

<p>class Forum extends AbstractAggregateRoot {</p>

<p>Discussion startDiscussion (</p>

<p>DiscussionId discussionId ,</p>

<p>Author author ,</p>

<p>String subject ) {</p>

<p>if ( this . isClosed ()) {</p>

<p>throw new IllegalStateException ( "Forum is closed" );</p>

<p>}</p>

<p>Discussion discussion = new Discussion (</p>

<p>this . tenant (),</p>

<p>this . forumId (),</p>

<p>discussionId ,</p>

<p>author ,</p>

<p>subject );</p>

<p>registerEvent ( new DiscussionStarted (...));</p>

<p>return discussion ;</p>

<p>}</p>

<p>}</p>

<p>포럼이 열린 경우에만 토론을 시작할 수 있다. : this.isClosed()</p>

<p>인자 5개 중 3개만 있으면 된다. : 나머지 2개는 포럼에서 제공</p>

<p>역시나 유비쿼터스 언어가 표현된다. : startDiscussion</p>

<p>서비스의 팩토리</p>

<p>package com . saasovation . collaboration . domain . model . collaborator ;</p>

<p>interface CollaboratorSerice {</p>

<p>Author authorFrom ( Tenant tenant , String identity );</p>

<p>Creator creatorFrom ( Tenant tenant , String identity );</p>

<p>Moderator moderatorFrom ( Tenant tenant , String identity );</p>

<p>Owner ownerFrom ( Tenant tenant , String identity );</p>

<p>Participant participantFrom ( Tenant tenant , String identity );</p>

<p>}</p>

<p>// infrastructure.services !!!</p>

<p>package com . saasovation . collaboration . infrastructure . services ;</p>

<p>class UserRoleToCollaborationService implements CollaboratorSerice {</p>

<p>@Override</p>

<p>public Author authorFrom ( Tenant tenant , String identity ) {</p>

<p>return ( Author ) userInRoleAdapter . toCollaborator (</p>

<p>tenant , identity , "Author" , Author . class );</p>

<p>)</p>

<p>}</p>

<p>}</p>

<p>package com . saasovation . collaboration . domain . model . collaborator ;</p>

<p>class Author extends Collaborator {</p>

<p>...</p>

<p>}</p>

<p>기술적 구현이므로 인프라 계층 의 모듈에 위치한다.</p>

<p>어댑터에 의존한다.</p>

<p>UserInRoleAdapter 는 외래 컨텍스트와 의사소통 책임만 갖는다.</p>

<p>CollaboratorTranslator 는 바운디드 컨텍스트 내 도메인 객체로 변환 책임만 갖는다.</p>

<p>협업에서는 identity 식별자와 액세스에서는 username</p>

<p>마무리</p>

<p>유비쿼터스 언어로 애그리게잇을 생성</p>

<p>애그리게잇의 팩토리 메서드 VS 서비스의 팩토리 메서드</p>

<p>IDDD 111장. 팩토리 was originally published by MJ at DevOOOOOOOOP on June 07, 2018.</p>

<p>source : http://redutan.github.io/2018/06/07/IDDD-chapter11</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>

  </div>
  <div class="entry-more-link">
    <a href="https://weblog.youre.space/redutan/2018/06/000947.html" itemprop="url">Continue reading</a>
  </div>
</article>


              <article id="entry-940" class="entry-asset entry asset hentry" itemscope itemType="http://schema.org/BlogPosting">
  <div class="asset-header">
    <h2 class="asset-name entry-title" itemprop="name"><a href="https://weblog.youre.space/redutan/2018/06/000940.html">IDDD 10장. 애그리게잇</a></h2>
    <footer class="asset-meta">
      <ul class="asset-meta-list">
        <li class="asset-meta-list-item">Posted on <time datetime="2018-06-05T01:36:12+09:00" itemprop="datePublished">June  5, 2018</time></li>
        <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

      </ul>
    </footer>
  </div>
  <div class="asset-content entry-content" itemprop="articleBody">
    <p>일관성 경계 내에서 엔터티와 값 객체의 묶음</p>

<p>일관성 경계 의 기준은 같은 트랜잭션인가로 검증된다.</p>

<p>애그리게잇 내의 불변식(invariant)?</p>

<p>스크럼 핵심 도메인에서 애그리게잇 사용하기</p>

<p>기능 목록</p>

<p>제품은 백로그 아이템과 릴리스, 스프린트를 포함한다.</p>

<p>새로운 제품 백로그 아이템을 계획했다.</p>

<p>새로운 제품 릴리스를 계획했다.</p>

<p>새로운 제품 스프린트 일정을 수립했다.</p>

<p>계획된 백로그 아이템에 관한 릴리스 일정을 수립할 수 있다.</p>

<p>일정이 잡힌 백로그 아이템은 스프린트로 커밋할 수 있다.</p>

<p>첫 번째 시도: 큰 클러스터의 애그리게잇</p>

<p>제품이 ~를 포함한다.</p>

<p>컴포지션 VS 객체 그래프</p>

<p>포함 VS (상호) 연결</p>

<p>도메인 로직</p>

<p>백로그 항목을 스프린트로 커밋하면, 이를 시스템에서 제거하도록 허용해선 안 된다.</p>

<p>스프린트가 백로그 항목을 커밋하면, 이를 시스템에서 제거하도록 허용해선 안 된다.</p>

<p>릴리스가 백로그 항목의 일정을 수립하면, 이를 시스템에서 제거하도록 허용해선 안 된다.</p>

<p>백로그 항목의 릴리스 일정을 수립하면, 이를 시스템에서 제거하도록 허용해선 안 된다.</p>

<p>class Product {</p>

<p>private Set  backlogItems ;</p>

<p>private String description ;</p>

<p>private String name ;</p>

<p>private ProductId productId ;</p>

<p>private Set  releases ;</p>

<p>private Set  sprints ;</p>

<p>private TenantId tenantId ;</p>

<p>}</p>

<p>아주 큰 애그리게잇으로 모델링된 Product</p>

<p>Product와는 별도의 애그리게잇 타입으로 모델린된 연관된 개념들</p>

<p>큰 애그리게잇으로 모델링하다보면 변경에 취약해져서 업데이트 상황에서 버전 충돌이 발생할 가능성이 커진다. 위를 예시로 두면 한 명이 backlogItem을 변경하고 다른 한 명이 Spring를 변경할 시 직적접 연관이 없음에도 불구하고 버전 충돌이 발생해서 업데이트가 실패할 확률이 커진다. (애그리게잇의 크기가 커짐에 따라서 충돌 확률도 더 커짐)</p>

<p>두 번째 시도: 다수의 애그리게잇</p>

<p>하나의 큰 애그리게잇 상 Product.java</p>

<p>class Product {</p>

<p>public void planBacklogItem (</p>

<p>String summary , String category , BacklogItemType type , StoryPorints storyPoints ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>public void scheduleRelease (</p>

<p>String name , String description , Date begins , Date ends ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>public void scheduleSprint (</p>

<p>String name , String goals , Date begins , Date ends ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>}</p>

<p>여러 개로 분리된 애그리게잇 상 Product.java</p>

<p>class Product {</p>

<p>public BacklogItem planBacklogItem (</p>

<p>String summary , String category , BacklogItemType type , StoryPorints storyPoints ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>public Release scheduleRelease (</p>

<p>String name , String description , Date begins , Date ends ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>public Sprint scheduleSprint (</p>

<p>String name , String goals , Date begins , Date ends ) {</p>

<p>...</p>

<p>}</p>

<p>...</p>

<p>}</p>

<p>일종의 factory 메서드로써 동작한다.</p>

<p>Product *Srvice 예시</p>

<p>@Service</p>

<p>class ProductBacklogItemService {</p>

<p>@Transactional</p>

<p>public void planProductBacklogItem (</p>

<p>String tenantId , String productId</p>

<p>String summary , String category</p>

<p>String backlogItemType , String storyPoints ) {</p>

<p>Product product =</p>

<p>productRepository . producetOfId (</p>

<p>new TenantId ( tenantId ),</p>

<p>new ProductId ( productId ));</p>

<p>BacklogItem plannedBacklogItem =</p>

<p>product . planBacklogItem (</p>

<p>summary , category ,</p>

<p>BacklogItemType . valueOf ( aBacklogItemType ),</p>

<p>StoryPoints . valueOf ( stroyPoints ));</p>

<p>backlogItemRepository . add ( plannedBacklogItem );</p>

<p>}</p>

<p>...</p>

<p>}</p>

<p>이와 같이 우린 밖으로 빼서 모델링함으로써(Modeling it away) 트랜잭션 실패 문제를 해결했다. 이제 BacklogItem , Release , Sprint 등의 인스턴스가 사용자의 요청에 따라 얼마든지 동시적으로 안전하게 생성될 수 있다.</p>

<p>그러나 큰 애그리게잇을 조금 다듬어서 동시성 문제를 해결할 수도 있을지도 모른다. 하이버네이트 매핑에서 optmistic-lock 옵셥을 false 로 설정해 트랜잭션 실패가 도미노 처럼 전달되는 상황을 피할 수 있다.</p>

<p>규칙: 진짜 고장자(invariant)를 일관성 경계 안에 모델링하라</p>

<p>*중요한 것은 진짜 고정자를 이해하는 것이다.</p>

<p>고장자(invariant) : 일관성(트랜잭션 일관성)을 유지해야만 한다는 비즈니스 규칙</p>

<p>트랜잭션 일관성 : 동기적, 원자적</p>

<p>결과적 일관성 : 비동기적</p>

<p>한 트랜잭션에 한 애그리게잇만 인스턴스만 포함 : 이는 너무 가혹한 것 같다.</p>

<p>규칙: 작은 애그리게잇으로 설계하라</p>

<p>이 Product 모델에선 다양한 기본 오퍼레이션이 수행될 동안 큰 컬랙션을 여럿 가져오게 된다.</p>

<p>이 큰 클러스터 애그리게잇은 성능이나 확장성이 절대로 좋을 수 없다. 이는 실패로 이어지는 악몽이 될 뿐이다. 거짓 고정자와 컴포지션적 편의성이 설계를 주도했기 때문에 시작부터 문제가 있었으며, 트랜잭션의 종료, 성능, 확장성의 측면에서 안 좋은 영향을 미쳤다.</p>

<p>작은 애그리게잇은? 다른 대상과 일관성을 유지</p>

<p>변경이 되면 엔터티</p>

<p>대치가 되면 값 객체 : 생각보다 상당히 많은 개념이 값 객체로 대치된다.</p>

<p>파생 금융상품 부문에서 약 70% 애그리게잇이 단 하나의 루트 엔터티로 구성된다.</p>

<p>작은 애그리게잇은</p>

<p>성능이 좋음</p>

<p>확장성이 좋음</p>

<p>트랜잭션이 성공할 가능성이 크다</p>

<p>유스케이스를 전부 믿지는 말라</p>

<p>하나의 유스케이스가 여러 트랜잭션을 발생 시킨다면 의심해 보자</p>

<p>이런 경우에서 결과적 일관성을 통해서 문제를 해결할 수 있다. + 지연 업데이트</p>

<p>물론 하나의 유스케이스가 하나의 트랜잭션일 필요는 없다.</p>

<p>규칙: ID로 다른 애그리게잇을 참조하라</p>

<p>객체 그래프가 연결되어 있다고 해서 같은 애그리게잇은 아니다. 그저 다른 애그리게잇을 연결했을 뿐이다.</p>

<p>여기도 결국 결과적 일관성 으로 이어진다.</p>

<p>애그리게잇 ID 참조를 통해 서로 함께 동작하도록 해보자</p>

<p>ID를 통해 경계 밖과 연결을 추론할 수 있는 BacklogItem 애그리게잇</p>

<p>class BacklogItem {</p>

<p>private ProductId productId ;</p>

<p>}</p>

<p>모델 탐색</p>

<p>객체 그래프 탐색과는 다르지만 리파지토르 와 ID 가 있으면 연관 모델을 탐색할 수 있다. : 단전될 도메인 모델(Disconnected Domain Model)</p>

<p>@Service</p>

<p>class ProductBacklogItemService {</p>

<p>@Transactional</p>

<p>public void assignTeaMemberToTask (</p>

<p>String aTenantId ,</p>

<p>String aBacklogItemId ,</p>

<p>String aTaskId ,</p>

<p>String aTeamMemberId ) {</p>

<p>BacklogItem backlogItem =</p>

<p>backlogItemRepository . findById (</p>

<p>new TenantId ( aTenantId ), new BacklogItemId ( aBacklogItemId ));</p>

<p>Team ofTeam =</p>

<p>teamRepository . findById (</p>

<p>backlogItem . tenantId (), backlogItem . teamId ());</p>

<p>backlogItem . assignTeamMemberToTask (</p>

<p>new TeamMemberId ( aTeamMemberId ), ofTeam , new TaskId ( aTaskId ));</p>

<p>}</p>

<p>}</p>

<p>확장성과 분산</p>

<p>ID 참조를 이용하게 되면 같은 영속화 플랫폼을 사용하지 않고 샤딩과 같은 확장을 통해서 일부 애그리게잇을 손쉽게 확장할 수 있다.</p>

<p>예를 들면 어떤 애그리게잇은 DB를 사용하고 연관되는 다른 애그리게잇은 NoSql을 사용할 수 있다.</p>

<p>도메인 이벤트를 통해서 외부 바운디드 컨텍스트로 분산처리를 더 가속화할 수 있다.</p>

<p>역시나 중요한 것은 결과적 일관성 이다.</p>

<p>규칙: 경계의 밖에서 결과적 일관성을 사용하라</p>

<p>결과적 일관성과 지연 시간 = 도메인 이벤트 발행</p>

<p>동시성 이슈로 인해서 발행된 이벤트 구독이 실패하면? 메시징 매커니즘을 통해서 Retry! > 이것은 쉽지가 않은 것 같다.</p>

<p>누가 해야 하는 일인지 확인하자</p>

<p>데이터의 일관성을 보장하는 주체가 유스케이스를 수행하는 사용자의 일인지를 질문해보자.</p>

<p>만약 그렇다면, 다른 애그리게잇의 규칙들은 고수하는 가운데 트랜잭션을 통해 일관성을 보장하도록 하자.</p>

<p>만약, 다른 사용자나 시스템이 해야 할 일이라면 결과적 일관성을 선택하자.</p>

<p>규칙을 어겨야하는 이유</p>

<p>첫 번째 이유: 사용자 인터페이스의 편의</p>

<p>두 번째 이유: 기술적 매커니즘의 부족</p>

<p>세 번째 이유: 글로벌 트랜잭션</p>

<p>개인적으로 안티패턴. 결과적 일관성을 사용하자</p>

<p>네 번째 이유: 쿼리 성능</p>

<p>캐싱을 통해서 어느정도 해결할 수 있다.</p>

<p>발견을 통해 통찰 얻기</p>

<p>Skip</p>

<p>구현</p>

<p>고유 ID와 루트 엔터리를 생성하라</p>

<p>값 객체 파트를 선호하라</p>

<p>‘데메테르 법칙’과 ‘묻지 말고 시켜라’를 사용하기</p>

<p>데메테르 법칙 : 정보은닉</p>

<p>묻지 말고 시켜라 : 정보은닉 + 응집력</p>

<p>낙관적 동시성</p>

<p>애그리게잇 루트에 버전을 통한 낙관적 락 기법</p>

<p>@Version : JPA를 이용하면 이 선언만으로도 낙관적 락 기법을 사용할 수 있다.</p>

<p>@Entity</p>

<p>@Table ( name = "orders" )</p>

<p>public class Order {</p>

<p>@Id</p>

<p>private Long id ;</p>

<p>@Version</p>

<p>private int version ;</p>

<p>private String description ;</p>

<p>}</p>

<p>의존성 주입을 피하라</p>

<p>애그리게잇에 서비스나 리파지토리를 주입하지 마라</p>

<p>마무리</p>

<p>가능하면 작은 애그리게잇으로 설계하자</p>

<p>일관성 경계, 트랜잭션, 고정자가 중요</p>

<p>객체 그래프 참조 VS ID 참조</p>

<p>경계 외부에서는 결과적 일관성</p>

<p>IDDD 10장. 애그리게잇 was originally published by MJ at DevOOOOOOOOP on June 05, 2018.</p>

<p>source : http://redutan.github.io/2018/06/05/IDDD-chapter10</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>

  </div>
  <div class="entry-more-link">
    <a href="https://weblog.youre.space/redutan/2018/06/000940.html" itemprop="url">Continue reading</a>
  </div>
</article>


              <article id="entry-917" class="entry-asset entry asset hentry" itemscope itemType="http://schema.org/BlogPosting">
  <div class="asset-header">
    <h2 class="asset-name entry-title" itemprop="name"><a href="https://weblog.youre.space/redutan/2018/05/000917.html">JPA에서 Value Object Collection 3가지 구현</a></h2>
    <footer class="asset-meta">
      <ul class="asset-meta-list">
        <li class="asset-meta-list-item">Posted on <time datetime="2018-05-29T23:55:29+09:00" itemprop="datePublished">May 29, 2018</time></li>
        <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

      </ul>
    </footer>
  </div>
  <div class="asset-content entry-content" itemprop="articleBody">
    <p>동기</p>

<p>팀 내에서 IDDD(Implementing Domain-Driven Design) 스터디 중 값 객체 Collection을 ORM(hibernate)을 이용하여 구현하는 예제 를 확인했습니다.</p>

<p>그러던 중 이게 아주 과거 hibernate xml 구성 기준이어서 현재 JPA(Sprin Data JPA)에서는 어떻게 구현되는지 궁금 해 하던 @동묘 가 저에게 직접 구현을 보고 싶다고 해서 포스팅 하게 되었습니다.</p>

<p>구현</p>

<p>3가지 구현 방법</p>

<p>Single Column</p>

<p>Entity</p>

<p>Join Table</p>

<p>예시 도메인</p>

<p>그룹은 애그리게잇 루트(엔터티)입니다.</p>

<p>그룹맴버는 값 객체입니다.</p>

<p>한 그룹에는 여러 그룹맴버가 있습니다. (Group#groupMembers )</p>

<p>그룹과 그룹맴버는 한 애그리게잇으로 묶입니다.</p>

<p>Many Values Serialized into a Single Column</p>

<p>groups.group_members 에 그룹맴버들 객체를 직렬화해서 저장합니다. 여기에서는 varchar(4000) 데이터타입으로써 JSON으로 직렬화 하겠습니다.</p>

<p>Java</p>

<p>GroupMember.java</p>

<p>@Embeddable</p>

<p>@Value</p>

<p>public class GroupMember {</p>

<p>private String name ;</p>

<p>@Enumerated ( EnumType . STRING )</p>

<p>private GroupMemberType type ;</p>

<p>// For JPA</p>

<p>GroupMember () {</p>

<p>this . name = null ;</p>

<p>this . type = null ;</p>

<p>}</p>

<p>// For Jackson</p>

<p>@JsonCreator</p>

<p>public GroupMember ( @JsonProperty ( "name" ) String name ,</p>

<p>@JsonProperty ( "type" ) GroupMemberType type ) {</p>

<p>this . name = name ;</p>

<p>this . type = type ;</p>

<p>}</p>

<p>}</p>

<p>Group.java</p>

<p>@Entity</p>

<p>@Table ( name = "GROUPS" )</p>

<p>@Getter</p>

<p>@EqualsAndHashCode</p>

<p>@ToString</p>

<p>@NoArgsConstructor ( access = AccessLevel . PACKAGE )</p>

<p>public class Group {</p>

<p>@Id</p>

<p>@GeneratedValue</p>

<p>private Long groupId ;</p>

<p>private String description ;</p>

<p>private String name ;</p>

<p>/**</p>

<p>* ORM과 한 열로 직렬화되는 여러 값 : ORM and Many Values Serialized into a Single Column</p>

<p>*/</p>

<p>@Convert ( converter = GroupMembersConverter . class )</p>

<p>@Column ( name = "GROUP_MEMBERS" , length = 4000 )</p>

<p>private Set  group1Members = new HashSet >();</p>

<p>...</p>

<p>}</p>

<p>GroupMembersConverter.java</p>

<p>@Converter</p>

<p>public class GroupMembersConverter implements AttributeConverter , String > {</p>

<p>private ObjectMapper om = new ObjectMapper ();</p>

<p>@Override</p>

<p>public String convertToDatabaseColumn ( Set  attribute ) {</p>

<p>return om . writeValueAsString ( attribute );</p>

<p>}</p>

<p>@Override</p>

<p>public Set  convertToEntityAttribute ( String dbData ) {</p>

<p>return om . readValue ( dbData , new TypeReference >() { });</p>

<p>}</p>

<p>}</p>

<p>SQL</p>

<p>Schema</p>

<p>create table groups (</p>

<p>group_id bigint not null ,</p>

<p>description varchar ( 255 ),</p>

<p>group_members varchar ( 4000 ), /* !!! */</p>

<p>name varchar ( 255 ),</p>

<p>primary key ( group_id )</p>

<p>);</p>

<p>Insert</p>

<p>insert into groups (</p>

<p>description , group_members , name , group_id</p>

<p>) values (</p>

<p>? , ? , ? , ?</p>

<p>);</p>

<p>Many Values Backed by a Database Entity</p>

<p>실질적으로는 Entity처럼 DB 스키마를 구성 하나 실제 객체지향세계(ex:Java Application)에서는 값 객체로 보이게 구현</p>

<p>이를 위해서 상속을 이용해서 식별자 속성을 은닉 시키는 것이 구현의 핵심</p>

<p>Java</p>

<p>IdentifiedValueObject.java</p>

<p>@MappedSuperclass</p>

<p>@NoArgsConstructor ( access = AccessLevel . PROTECTED )</p>

<p>public abstract class IdentifiedValueObject {</p>

<p>@Id</p>

<p>@GeneratedValue</p>

<p>@Getter ( AccessLevel . PACKAGE )</p>

<p>@Setter ( AccessLevel . PACKAGE )</p>

<p>private Long id ; // 패키지 접근제어를 통해서 식별자 은닉. 단, hibernate는 접근 가능</p>

<p>}</p>

<p>GroupMember.java</p>

<p>@Entity</p>

<p>@Table ( name = "GROUP_MEMBERS" )</p>

<p>@Value</p>

<p>@EqualsAndHashCode ( callSuper = false )</p>

<p>public class GroupMember extends IdentifiedValueObject {</p>

<p>private String name ;</p>

<p>@Enumerated ( EnumType . STRING )</p>

<p>private GroupMemberType type ;</p>

<p>// For JPA</p>

<p>GroupMember () {</p>

<p>this . name = null ;</p>

<p>this . type = null ;</p>

<p>}</p>

<p>}</p>

<p>Group.java</p>

<p>public class Group {</p>

<p>...</p>

<p>/**</p>

<p>* ORM과 데이터베이스 엔터티로 지원되는 여러 값 : ORM and Many Values Backed by a Database Entity</p>

<p>*/</p>

<p>@OneToMany ( cascade = CascadeType . ALL , orphanRemoval = true ) // Aggregate Root 를 위한 일관성 설정</p>

<p>@JoinColumn ( name = "GROUP_ID" )</p>

<p>private Set  groupMembers = new HashSet >();</p>

<p>...</p>

<p>}</p>

<p>SQL</p>

<p>Schema</p>

<p>create table groups (</p>

<p>group_id bigint not null ,</p>

<p>description varchar ( 255 ),</p>

<p>name varchar ( 255 ),</p>

<p>primary key ( group_id )</p>

<p>);</p>

<p>create table group_members (</p>

<p>id bigint not null , // PK !!</p>

<p>name varchar ( 255 ),</p>

<p>type varchar ( 255 ),</p>

<p>group_id bigint ,</p>

<p>primary key ( id )</p>

<p>)</p>

<p>alter table group_members</p>

<p>add constraint fk_groups_group_members</p>

<p>foreign key ( group_id ) references groups ;</p>

<p>Insert</p>

<p>insert into groups ( description , name , group_id ) values ( ? , ? , ? )</p>

<p>insert into group_members ( name , type , id ) values ( ? , ? , ? )</p>

<p>insert into group_members ( name , type , id ) values ( ? , ? , ? )</p>

<p>update group_members set group_id =? where id =? /* Update ?! */</p>

<p>update group_members set group_id =? where id =?</p>

<p>일반적으로 가장 무난하며, IDDD 책에서는 저자가 가장 추천한 방식</p>

<p>Many Values Backed by a Join Table</p>

<p>group_members 을 테이블로 분리하는데 이 테이블은 PK가 없이 groups 의 PK를 FK로 가지는 Join Table로 구현</p>

<p>Java</p>

<p>Group.java</p>

<p>public class Group {</p>

<p>@Id</p>

<p>@GeneratedValue</p>

<p>private Long groupId ;</p>

<p>private String description ;</p>

<p>private String name ;</p>

<p>/**</p>

<p>* ORM과 조인 테이블로 지원되는 여러 값 : ORM and Many Values Backed by a Join Table</p>

<p>*/</p>

<p>@ElementCollection</p>

<p>@CollectionTable ( name = "GROUP_MEMBERS" , joinColumns = @JoinColumn ( name = "GROUP_ID" ))</p>

<p>private Set  groupMembers = new HashSet >();</p>

<p>...</p>

<p>}</p>

<p>SQL</p>

<p>Schema</p>

<p>create table groups (</p>

<p>group_id bigint not null ,</p>

<p>description varchar ( 255 ),</p>

<p>name varchar ( 255 ),</p>

<p>primary key ( group_id )</p>

<p>);</p>

<p>create table group_members ( /* No PK */</p>

<p>group_id bigint not null ,</p>

<p>name varchar ( 255 ),</p>

<p>type varchar ( 255 )</p>

<p>);</p>

<p>alter table group_members</p>

<p>add constraint fk_groups_group_members</p>

<p>foreign key ( group_id ) references groups ;</p>

<p>Insert</p>

<p>insert into groups ( description , name , group_id ) values ( ? , ? , ? );</p>

<p>insert into group_members ( group_id , name , type ) values ( ? , ? , ? );</p>

<p>insert into group_members ( group_id , name , type ) values ( ? , ? , ? );</p>

<p>이슈</p>

<p>값 객체 Collection에 새로운 값이 추가되거나 기존 값이 변경될 시 All Delete and Re-insert</p>

<p>@ElementCollection 을 통해 변경이 발생할 시, 전체를 지우고 다시 입력하는 이슈가 있음.</p>

<p>이를 완화시키기 위해서 @OrderColumn 을 추가하는 방법이 있긴하나 완벽하지는 않음</p>

<p>public class Group {</p>

<p>...</p>

<p>@ElementCollection</p>

<p>@CollectionTable ( name = "GROUP_MEMBERS" , joinColumns = @JoinColumn ( name = "GROUP_ID" ))</p>

<p>@OrderColumn // !!!</p>

<p>private Set  groupMembers = new HashSet >();</p>

<p>...</p>

<p>}</p>

<p>Summary</p>

<p>Single Column</p>

<p>Entity</p>

<p>Join Table</p>

<p>Reference</p>

<p>소스코드 : https://github.com/redutan/ddd-values</p>

<p>Implementing Domain-Driven Design. Vaughn Vernon</p>

<p>자바 ORM 표준 JPA 프로그래밍. 김영한</p>

<p>http://kwonnam.pe.kr/wiki/java/jpa/elementcollection</p>

<p>JPA에서 Value Object Collection 3가지 구현 was originally published by MJ at DevOOOOOOOOP on May 29, 2018.</p>

<p>source : http://redutan.github.io/2018/05/29/ddd-values-on-jpa</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>

  </div>
  <div class="entry-more-link">
    <a href="https://weblog.youre.space/redutan/2018/05/000917.html" itemprop="url">Continue reading</a>
  </div>
</article>


              <article id="entry-909" class="entry-asset entry asset hentry" itemscope itemType="http://schema.org/BlogPosting">
  <div class="asset-header">
    <h2 class="asset-name entry-title" itemprop="name"><a href="https://weblog.youre.space/redutan/2018/05/000909.html">IDDD 9장. 모듈</a></h2>
    <footer class="asset-meta">
      <ul class="asset-meta-list">
        <li class="asset-meta-list-item">Posted on <time datetime="2018-05-28T13:54:15+09:00" itemprop="datePublished">May 28, 2018</time></li>
        <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

      </ul>
    </footer>
  </div>
  <div class="asset-content entry-content" itemprop="articleBody">
    <p>Java: 패키지</p>

<p>C#: 네임스페이스</p>

<p>Roby: 모듈</p>

<p>모듈로 설계하기</p>

<p>모듈 : 도메인 객체의 컨테이너</p>

<p>규칙</p>

<p>모델링의 개념에 맞춰 모듈을 설계하자</p>

<p>유비쿼터스 언어에 맞춰 모듈을 명명하자</p>

<p>모델에서 사용하는 일반적인 컴포넌트 타입이나 패턴에 따라서 기계적으로 모듈을 생성하지 말자</p>

<p>느슨하게 결합된 모듈을 설계하자.</p>

<p>결합이 필요하다면 짝이 되는 모듈 사이에서 비순환적 의존성이 형성되도록 노력하자</p>

<p>자식 모듈과 부모 모듈 사이에 규칙은 느슨하게 하자</p>

<p>모듈을 모델의 정적인 개념에 따라 만들지 말고, 모듈이 담고 있는 객체에 맞추도록 하자</p>

<p>주방의 서랍에 식기류가 포크와 나이프와 스푼별로 잘 정리돼 있음</p>

<p>기본 모듈 명명 규칙</p>

<p>Java: com.saasovation</p>

<p>C#: SaaSOvation</p>

<p>모델을 위한 모듈 명명 규칙</p>

<p>바운디드 컨텍스트</p>

<p>com.saasovation.identityaccess</p>

<p>com.saasovation.collovoration</p>

<p>com.saasovation.agilepm</p>

<p>모듈 구성 예시</p>

<p>com.saasovation.identityaccess</p>

<p>domain.model</p>

<p>결론은 여러분 팀의 몫이다.</p>

<p>애자일 프로젝트 관리 컨텍스트의 모듈</p>

<p>com.saasovation.agilepm</p>

<p>domain</p>

<p>model</p>

<p>product</p>

<p>backlogitem</p>

<p>release</p>

<p>sprint</p>

<p>tenant</p>

<p>team</p>

<p>이 팀은 모듈 사이의 결합도 문제보다 정리 에 중점을 뒀다.</p>

<p>다른 계층 속의 모듈</p>

<p>계층</p>

<p>모듈</p>

<p>비고</p>

<p>사용자 인터페이스</p>

<p>com.saasovation.agilepm.resources</p>

<p>ui</p>

<p>애플리케이션</p>

<p>com.saasovation.agilepm.application</p>

<p>도메인</p>

<p>com.saasovation.agilepm.domain</p>

<p>인프라</p>

<p>com.saasovation.agilepm.infrastructure</p>

<p>adapter</p>

<p>바운디드 컨텍스트보다 모듈</p>

<p>모듈은 응집력이 낮은 경우 분리하기 위한 컨테이너이고, 바운디드 컨텍스트는 그저 경계일 뿐이다.</p>

<p>어짜피 모듈은 상향식(bottom-up)으로 설계하게된다.</p>

<p>모듈 내의 컴포넌트들에 따라서 나눠질 수도 합쳐질 수도 있다. 중요한 것은 도메인 로직과 유비쿼터스 언어에 따르는 것이다.</p>

<p>마무리</p>

<p>유비쿼터스 언어를 표현한다.</p>

<p>모듈 설계의 예시!!</p>

<p>기계적인 모듈 설계는 창의성을 방해한다.</p>

<p>바운디드 컨텍스트 분리보다 모듈 사용이 먼저다.</p>

<p>IDDD 9장. 모듈 was originally published by MJ at DevOOOOOOOOP on May 28, 2018.</p>

<p>source : http://redutan.github.io/2018/05/28/IDDD-chapter09</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>

  </div>
  <div class="entry-more-link">
    <a href="https://weblog.youre.space/redutan/2018/05/000909.html" itemprop="url">Continue reading</a>
  </div>
</article>


              <article id="entry-893" class="entry-asset entry asset hentry" itemscope itemType="http://schema.org/BlogPosting">
  <div class="asset-header">
    <h2 class="asset-name entry-title" itemprop="name"><a href="https://weblog.youre.space/redutan/2018/05/000893.html">IDDD 8장. 도메인 이벤트</a></h2>
    <footer class="asset-meta">
      <ul class="asset-meta-list">
        <li class="asset-meta-list-item">Posted on <time datetime="2018-05-24T01:18:59+09:00" itemprop="datePublished">May 24, 2018</time></li>
        <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

      </ul>
    </footer>
  </div>
  <div class="asset-content entry-content" itemprop="articleBody">
    <p>Publish-Subscribe</p>

<p>언제 그리고 왜 도메인 이벤트를 사용할까?</p>

<p>도메인 내 어떤 사건이 발생했을 때</p>

<p>한 트랜잭션에는 한 애그리게잇만 커밋</p>

<p>이벤트의 모델링</p>

<p>어떤 명령에서 어떤 사건이 발생했었음</p>

<p>Command : BacklogItem#commitTo(Spring)</p>

<p>Event : BacklogItemCommitted</p>

<p>백로그 항목이 커밋됐다.(과거형)</p>

<p>package com . saasovation . agilepm . domain . model . product ;</p>

<p>@Value</p>

<p>class BacklogItemCommitted implements DomainEvent {</p>

<p>Date occurredOn ;</p>

<p>BacklogItemId backlogItemId ;</p>

<p>SpringId committedToSprintId ;</p>

<p>TenantId tenantId ;</p>

<p>}</p>

<p>package com . saasovation . agilepm . domain . model ;</p>

<p>interface DomainEvent {</p>

<p>Date occurredOn ();</p>

<p>}</p>

<p>추가사항</p>

<p>멱등성</p>

<p>더 풍부한 상태 전달 (이벤트 소싱!)</p>

<p>애그리게잇의 특성과 함께하기</p>

<p>이벤트를 애그리게잇을 통해서 영속화</p>

<p>식별자</p>

<p>이벤트를 애그리게잇으로 모델링하면 식별자가 필요하다.</p>

<p>도메인 이벤트를 바운디드 컨텍스트 외부로 발행 시 식별자가 필요(With rabbitmq)</p>

<p>외부 구독자 입장에서는 멱등성 관리를 위해서 식별자를 할당할 수 있음</p>

<p>equals 로 일정 부분 해결할 수도 있다 (in 로컬 바운디드 컨텍스트)</p>

<p>도메인 모델에서 이벤트 발행하기</p>

<p>Light-Weight Publish-Subscribe</p>

<p>Reference : https://github.com/redutan/redutan.github.io/wiki/Domain-Event-on-Springframework</p>

<p>발행자</p>

<p>class BacklogItem extends AbstractAggregateRoot  {</p>

<p>void commitTo ( Sprint spint ) {</p>

<p>// Some domain logic</p>

<p>super . registerEvent ( new BacklogItemCommitted (</p>

<p>this . tenantId (),</p>

<p>this . backlogItemId (),</p>

<p>this . sprintId ()</p>

<p>));</p>

<p>}</p>

<p>}</p>

<p>class BacklogItemService { // Application Service</p>

<p>@TransactionalEventListener</p>

<p>void commitBacklogItem (...) {</p>

<p>backlogItem . commitTo ( sprint ); // Publish BacklogItemCommitted event</p>

<p>}</p>

<p>}</p>

<p>구독자</p>

<p>class BacklogItemService { // Application Service</p>

<p>@TransactionalEventListener</p>

<p>void handleBacklogItemCommitted ( BacklogItemCommitted event ) {</p>

<p>// BacklogItemCommitted 구독 후 처리</p>

<p>}</p>

<p>}</p>

<p>중요한 것은 결과적 일관성</p>

<p>뉴스를 원격 바운디드 컨텍스트로 전파하기</p>

<p>시스템 간 결과적 일관성 확보</p>

<p>메시징 인프라의 일관성</p>

<p>구현방법</p>

<p>도메인 모델과 메시지 인프라 저장소 공유</p>

<p>원격 DB with XA</p>

<p>이벤트 저장소</p>

<p>자치 서비스와 시스템</p>

<p>자치 서비스 : 이벤트를 통해서 시스템 간 결합도(독립성!)를 줄이는 기법 (No-RPC)</p>

<p>자치 서비스의 단위는 바운디드 컨텍스트가 되면 좋은 것 같다.</p>

<p>지연 시간 허용</p>

<p>결과적 일관성 을 위해서</p>

<p>도메인 별로 그 때 그 때 달라요.</p>

<p>시스템의 허용치를 만족시키면서도 잘 수행되도록 아키텍처 품질을 높여야 한다.</p>

<p>이벤트 저장소</p>

<p>이벤트의 상태를 유지하기 위해서 저장하는 것이 요구되는 경우가 많다.</p>

<p>@Aspect</p>

<p>class IdentityAccessEventProcessor {</p>

<p>@Before ( "execution(* com.saasovation.identityaccess.application.*.**..))" )</p>

<p>public void listen () {</p>

<p>DomainEventPublisher . instance ()</p>

<p>. subscribe ( new DomainEventSubscriber () {</p>

<p>public void handleEvent ( DomainEvent aDomainEvent ) {</p>

<p>store ( aDomainEvent );</p>

<p>}</p>

<p>public Class  subscribedToEventType () {</p>

<p>return DomainEvent . class ; // 모든 도메인 이벤트</p>

<p>}</p>

<p>});</p>

<p>}</p>

<p>private void store ( DomainEvent aDomainEvent ) {</p>

<p>EventStore . instance (). append ( aDomainEvent );</p>

<p>}</p>

<p>}</p>

<p>class StoreEvent {</p>

<p>void append ( DomainEvent aDomainEvent ) {</p>

<p>String eventSerializatoin =</p>

<p>EventStore . objectSerializer (). serialize ( aDomainEvent );</p>

<p>StoredEvent storedEvent =</p>

<p>new StoredEvent (</p>

<p>aDomainEvent . getClass (). getName (),</p>

<p>aDomainEvent . occuredOn (),</p>

<p>eventSerialization );</p>

<p>this . session (). save ( storedEvent );</p>

<p>this . setStoredEvent ( storedEvent );</p>

<p>}</p>

<p>}</p>

<p>CREATE TABLE tbl_stored_event (</p>

<p>event_id int ( 11 ) NOT NULL auto_increment ,</p>

<p>event_body varchar ( 65000 ) NOT NULL ,</p>

<p>occurred_on datetime NOT NULL ,</p>

<p>type_name varchar ( 100 ) NOT NULL ,</p>

<p>PRIMARY KEY ( event_id )</p>

<p>)</p>

<p>저장된 이벤트의 전달을 위한 아키텍처 스타일</p>

<p>레스트품 리소스로서 알림 발행하기</p>

<p>이벤트를 REST/WEB API로 발행한다. (이벤트 아이디나 애그리게잇 아이디를 전달)</p>

<p>이벤트 저장소를 통해서 조회하거나, 애그리게잇을 직접 조회한다.</p>

<p>구독 측에서 발행측에 다시 상세 이벤트 정보를 조회한 후 처리한다.</p>

<p>메시징 미들웨어를 통한 알림 발행</p>

<p>메시징 미들웨어를 통해서 이벤트를 발행한다.</p>

<p>메시징 미들웨어를 구독한 구독 측에서 발행 측의 상세 이벤트 정보를 조회한 후 처리 한다.</p>

<p>발행과 구독은 exchange나 queue 개념으로 연결된다.</p>

<p>구현</p>

<p>Skip</p>

<p>멱등 수신자 처리가 중요하다 : At least once</p>

<p>멱등성 : 오퍼레이션이 두 번 이상 수행되어도, 한 번만 수행했을 때와 같은 결과에 이르는 동작을 의미</p>

<p>궁극적으로 이벤트를 추적해야하는 경우가 생기기 때문에 이벤트 저장 기능이 거의 필수적으로 요구된다.</p>

<p>그리고 추적 일관성을 위해서 이벤트 저장은 도메인 로직과 트랜잭션으로 묶이는 것이 중요하다.</p>

<p>마무리</p>

<p>이벤트 만의 고유 식별자가 요구된다.</p>

<p>이벤트 저장소도 필요</p>

<p>어짜피 발행-구독!</p>

<p>멱등성 또는 중복 발행 or 수신 제거 확보</p>

<p>IDDD 8장. 도메인 이벤트 was originally published by MJ at DevOOOOOOOOP on May 24, 2018.</p>

<p>source : http://redutan.github.io/2018/05/24/IDDD-chapter08</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>

  </div>
  <div class="entry-more-link">
    <a href="https://weblog.youre.space/redutan/2018/05/000893.html" itemprop="url">Continue reading</a>
  </div>
</article>


              <article id="entry-858" class="entry-asset entry asset hentry" itemscope itemType="http://schema.org/BlogPosting">
  <div class="asset-header">
    <h2 class="asset-name entry-title" itemprop="name"><a href="https://weblog.youre.space/redutan/2018/05/000858.html">IDDD 4장. 아키텍처</a></h2>
    <footer class="asset-meta">
      <ul class="asset-meta-list">
        <li class="asset-meta-list-item">Posted on <time datetime="2018-05-10T19:08:23+09:00" itemprop="datePublished">May 10, 2018</time></li>
        <li class="asset-meta-list-item">by <span class="author entry-author vcard"><a class="fn url" href="http://weblog.youre.space/vergence/">Sangyong Gwak</a></span></li>

  

      </ul>
    </footer>
  </div>
  <div class="asset-content entry-content" itemprop="articleBody">
    <p>실제 요구(도메인)가 아키텍처 스타일과 패턴의 사용을 유도해야 한다.</p>

<p>도메인이 기술 보다 먼저다.</p>

<p>성공한 CIO와의 인터뷰</p>

<p>Server-Client Architecture</p>

<p>계층형 아키텍처</p>

<p>DIP, QP, PSA, DDD-Lite</p>

<p>헥사고날 아키텍처</p>

<p>To Mobile, Cloud</p>

<p>CQRS</p>

<p>Materialized Views</p>

<p>Event-Driven Architecture</p>

<p>Pipeline + Filter</p>

<p>Saga 패턴</p>

<p>Long-lived transaction as a sequence of subtransactions.</p>

<p>In a distributed system</p>

<p>이벤트 소싱</p>

<p>모든 변경을 추적 (ex: 보안 감사 등)</p>

<p>이러한 아키텍처 덕분에 결국 회사에 돈이 된다</p>

<p>계층</p>

<p>그림 4.1 DDD가 적용된 전통적인 계층 아키텍처</p>

<p>[출처] https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/</p>

<p>도메인 모델과 비즈니스 로직을 도메인 계층에 격리</p>

<p>하위 계층에만 의존 - 아래에서 위쪽으로 직접 참조 불가 (하지만 Observer 사용 가능)</p>

<p>느슨한 연결 : UI가 애플리케이션(바로 하위) 뿐만 아니라 도메인이나 인프라에도 의존 가능</p>

<p>UI 계층</p>

<p>View나 API 제공</p>

<p>도메인 모델이 아닌 표현 모델(DTO)를 사용 추천</p>

<p>애플리케이션 계층</p>

<p>UI로 부터 매개변수를 받아 리파지토리를 사용해 애그리게잇을 획득하고, 커맨드를 위임</p>

<p>보안과 트랜젝션 담당 (일반적으로 보안을 UI로 올리는 것 같음)</p>

<p>도메인 로직 없으며 도메인 모델(애그리게잇, 도메인 서비스 등)에 위임</p>

<p>도메인 모델에서 발행한 도메인 이벤트를 구독(subscribe)</p>

<p>@Transactionl</p>

<p>void commitBackLogItemToSpring (</p>

<p>String aTanantId , String aBackLogItemId , String aSprintId ) {</p>

<p>// 재료(Aggregate) 준비</p>

<p>BacklogItem backlogItem =</p>

<p>backlogItemRepository . backlogItemOfId ( aTanantId , aBacklogItemId );</p>

<p>Sprint sprint sprintRepository . sprintOfId ( aSprintId );</p>

<p>// 커맨드 위임</p>

<p>backlogItem . commitTo ( sprint );</p>

<p>}</p>

<p>DIP</p>

<p>상위 수준의 모듈은 하위 수준 모듈에 의존해선 안된다. 둘 모두는 반드시 추상화에 의존해야 한다.</p>

<p>추상화는 세부사항에 의존해선 안 된다. 세부사항은 추상화에 의존해야 한다.</p>

<p>하위 구현 컴포넌트가 상위 콤포넌트가 정의한 인터페이스에 의존해야한다.</p>

<p>어라 그러다 보니 계층이 없어진다. 여기에 대칭성을 더하면 어떻게 될까?</p>

<p>헥사고날 또는 포트와 어댑터</p>

<p>헥사고날 아키텍처</p>

<p>[출처] http://alistair.cockburn.us/Hexagonal+architecture</p>

<p>Texi handling Hexagonal Architecture</p>

<p>[출처] https://github.com/seongminwoo/study/blob/master/7-part_series_about_microservices.md</p>

<p>헥사고날의 장점</p>

<p>기능적 요구사항에 따라 애플리케이션 내부를 설계</p>

<p>UI, Infra는 그 다음이다.</p>

<p>애플리케이션 내부가 캡슐화 된다.</p>

<p>Adapter를 통해 기술과 분리</p>

<p>서비스 지향(SOA)</p>

<p>중요한 것은 기술 보다 비즈니스(도메인) 가치가 우선해야 한다</p>

<p>REST: 표현 상태 전송</p>

<p>[출처] https://martinfowler.com/articles/richardsonMaturityModel.html</p>

<p>RESTful HTTP 서버의 주요 특징</p>

<p>Resource : URI</p>

<p>Verbs : GET, POST, PUT, DELETE, …</p>

<p>Hypermedia : 연결된 리소스를 제공. 상호작용, 클라이언트 무상태</p>

<p>RESTful HTTP 클라이언트의 주요 특징</p>

<p>Hypermedia를 바탕으로 상호 작용한다.</p>

<p>REST와 DDD</p>

<p>도메인 모델을 RESTful로 바로 노출하는 것은 좋지 않다.</p>

<p>도메인 모델의 변경이 API와 연결되기 때문에 변경에 취약해지며, 클라이언트와 호환성이 깨진다.</p>

<p>해결책</p>

<p>도메인 모델 -> 표현 모델을 조립 (추천)</p>

<p>Assembler + DTO (PoEAA)</p>

<p>각 상황 별 공유 도메인 모델 사용</p>

<p>공유커널</p>

<p>왜 REST인가</p>

<p>느슨함</p>

<p>CQRS</p>

<p>사용자가 필요로하는 데이터 뷰를 리파지토리로 쿼리하기란 어려울 수 있다.</p>

<p>CQRS = 객체 설계 원칙 + CQS</p>

<p>Command : 객체의 상태를 수정, Void 형</p>

<p>Query : 값을 반환, 수정 X</p>

<p>구현</p>

<p>애그리게잇은 오직 커맨드 메소드만 가지고 있음.(커맨드 모델)</p>

<p>쿼리를 위한 뷰 전용 모델(쿼리 모델)을 생성</p>

<p>CQRS의 영역 살펴보기</p>

<p>출처 : https://docs.microsoft.com/ko-kr/azure/architecture/guide/architecture-styles/cqrs</p>

<p>참고 : https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs</p>

<p>클라이언트와 쿼리 처리기</p>

<p>쿼리 모델(읽기 모델)</p>

<p>필요한 수 만큼 뷰를 지원하기</p>

<p>실용적으로 하라</p>

<p>데이터베이스 테이블 뷰가 오버헤드의 원인이 되지 않을까?</p>

<p>클라이언트가 커맨트 처리를 주도한다.</p>

<p>UI to Argument</p>

<p>커맨드 처리기</p>

<p>카테고리 스타일 : 1 class n methods</p>

<p>전용 스타일 : 1 class 1 method</p>

<p>커맨드 모델(쓰기 모델)은 행동을 수행한다.</p>

<p>public void commitTo ( Sprint aSprint ) {</p>

<p>...</p>

<p>DomainEventPublisher</p>

<p>. instance ()</p>

<p>. publish ( new BacklogItemCommitted (</p>

<p>this . tenant (),</p>

<p>this . backlogItemId (),</p>

<p>this . sprintId ()</p>

<p>));</p>

<p>}</p>

<p>어떤 경우든 쿼리 모델을 업데이트시키기 위해선 도메인 이벤트를 게시해야 한다.</p>

<p>이벤트 구독자가 쿼리 모델을 업데이트 한다.</p>

<p>동기도 가능하고 비동기 도 가능하다.</p>

<p>결국은 일관성이 유지되는 쿼리 모델 다루기</p>

<p>Eventually consistent</p>

<p>지연되는 뷰 데이터 동기화를 해결해야한다.</p>

<p>낙관적 업데이트 기법!</p>

<p>클라이언트에서 publish/subscribe 기법</p>

<p>결국은 동기화되는 지연시간이 문제</p>

<p>이벤트 주도 아키텍처(EDA)</p>

<p>이벤트의 생산, 감지, 소비와 이벤트에 따른 응답 등을 촉진하는 소프트웨어 아키텍처</p>

<p>From 도메인 이벤트</p>

<p>파이프와 필터</p>

<p>$ cat phone_number.txt | grep 303 | wc -1</p>

<p>Spring Cloud Data Flow</p>

<p>그림 4.8 필터를 처리하는 이벤트를 보냄으로써 파이프라인이 만들어진다.</p>

<p>[출처] http://zhangyi.farbox.com/post/coding/understand-scala-stack</p>

<p>이는 가상의 예제이자 개념적 부분을 강조했을 뿐이다. 실제 엔터프라이즈에선 큰 문제를 좀 더 작은 단계로 나누기 위해 이 패턴을 사용하며, 좀 더 쉽게 분산 처리를 이해하고 관리하도록 해준다.</p>

<p>또한 여러 시스템이 오직 자신이 할 일(도메인)만을 걱정하게 되게 해주기도 한다.</p>

<p>장기 실행 프로세스</p>

<p>컴포지트</p>

<p>애그리게잇 집합</p>

<p>이벤트</p>

<p>역시나 중요한 것은 결과적 일관성 (Eventual Consistency)</p>

<p>Saga Pattern</p>

<p>Events/Choreography</p>

<p>Rollback</p>

<p>referecne : https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/</p>

<p>이벤트 소싱</p>

<p>거의 완벽한 수준의 변경 추적</p>

<p>[출처] https://docs.microsoft.com/ko-kr/azure/architecture/patterns/event-sourcing</p>

<p>Replay : 이벤트소싱에서 이벤트를 되감아서 특정 버전 상태로 되돌리는 것</p>

<p>하지만 최신 버전 Replay는 병목의 원인</p>

<p>이를 해결하기 위해서 최신 버전의 상태를 Snapshot 으로 지정해서 최적화</p>

<p>데이터 패브릭과 그리드 기반 분산 컴퓨팅</p>

<p>분산 캐시</p>

<p>ex) hazelcast</p>

<p>데이터 복제</p>

<p>캐시 master/slave</p>

<p>복제를 통한 장애 극복</p>

<p>이벤트 유실 제거 (이벤트 publish/subscribe도 가능)</p>

<p>이벤트 주도 패브릭과 도메인 이벤트</p>

<p>For Domain Event</p>

<p>지속적 쿼리</p>

<p>For CQRS</p>

<p>분산 처리</p>

<p>For Saga 또는 배치 병렬 처리</p>

<p>마무리</p>

<p>Layerd Architecture > DIP > Hexagonal Architecture</p>

<p>SOA, REST, 분산 컴퓨팅</p>

<p>CQRS, Event Sourcing, pipe/filter, Saga</p>

<p>IDDD 4장. 아키텍처 was originally published by MJ at DevOOOOOOOOP on May 08, 2018.</p>

<p>source : http://redutan.github.io/2018/05/08/IDDD-chapter04</p>

<p>---------------------------------------------------------------------------<br />Visit this link to stop these emails: http://zpr.io/nXidW</p>

  </div>
  <div class="entry-more-link">
    <a href="https://weblog.youre.space/redutan/2018/05/000858.html" itemprop="url">Continue reading</a>
  </div>
</article>


              <nav class="page-navigation entry-navigation pagination content-nav">
  <ul class="pagination-list">
<li class="page-navigation-list-item page-navigation-prev"><a rel="prev" href="http://connexus-recall.youre.space:5000/mt-search.cgi?IncludeBlogs=17&amp;template_id=1413&amp;limit=10&amp;archive_type=Index&amp;page=2">Older entries</a></li>
  </ul>
</nav>


            </div>
            <aside class="widgets related" role="complementary">
              <nav class="widget-search widget">
  <div class="widget-content">
    <form method="get" id="search" action="http://connexus-recall.youre.space:5000/mt-search.cgi">
      <div>
        <input type="text" name="search" value="" placeholder="Search...">

        <input type="hidden" name="IncludeBlogs" value="17">

        <input type="hidden" name="limit" value="20">
        <button type="submit" name="button">
          <img alt="Search" src="https://weblog.youre.space/mt-static/support/theme_static/rainier/img/search-icon.png">
        </button>
      </div>
    </form>
  </div>
</nav>
<nav class="widget-archive-dropdown widget">
  <h3 class="widget-header">Archives</h3>
  <div class="widget-content">
    <select>
      <option>Select a Month...</option>
    
      <option value="https://weblog.youre.space/redutan/2018/07/">July 2018</option>
    
  
    
      <option value="https://weblog.youre.space/redutan/2018/06/">June 2018</option>
    
  
    
      <option value="https://weblog.youre.space/redutan/2018/05/">May 2018</option>
    
  
    
      <option value="https://weblog.youre.space/redutan/2018/04/">April 2018</option>
    
  
    
      <option value="https://weblog.youre.space/redutan/2018/02/">February 2018</option>
    
    </select>
  </div>
</nav>
    
  

<div class="widget-syndication widget section">
  <div class="widget-content">
    <p><img src="https://weblog.youre.space/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="https://weblog.youre.space/redutan/atom.xml">Subscribe to this blog's feed</a></p>

  </div>
</div>

            </aside>
          </div>
        </div>
        <footer id="footer" role="contentinfo">
          <div id="footer-inner">
            <div id="footer-content">
  <nav role="navigation">
          <ul>
            <li><a href="https://weblog.youre.space/redutan/">Home</a></li>


          </ul>
        </nav>

  <p class="license">&copy; Copyright 2019.</p>
  <p class="poweredby">Powered by <a href="http://www.movabletype.org/">Movable Type</a></p>
</div>
          </div>
        </footer>
      </div>
    </div>
    <script src="https://weblog.youre.space/mt-static/jquery/jquery.min.js"></script>
    <script src="https://weblog.youre.space/redutan/mt-theme-scale2.js"></script>
  </body>
</html>
